{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Pyglaze","text":"<p>Source Code: https://github.com/GlazeTech/pyglaze</p> <p>Documentation Version: 0.4.1</p> <p>This is the Pyglaze API documentation. Pyglaze is a python library used to operate the devices of Glaze Technologies. If you have a feature request or discover a bug, please create an issue here and we will look at it ASAP!</p>"},{"location":"#usage","title":"Usage","text":"<p>Pyglaze provides two main interfaces for operating Glaze devices: The <code>Scanner</code> and the The <code>GlazeClient</code>, where <code>Scanner</code>is a synchronous scanner, only scanning when requested, and <code>GlazeClient</code> is an asynchronous scanner, continuously scanning in the background.</p>"},{"location":"#glazeclient","title":"GlazeClient","text":"<p>Using the <code>GlazeClient</code>is the preferred way to acquire scans. Before starting the scanner, a device configuration must be created. Depending on the type of device, different configurations are required, see e.g. a definition here. Be sure to replace <code>mock_device</code> and <code>mock_delay</code> with suitable values. Here, we will use a <code>LeDeviceConfiguration</code>.</p> <p><pre><code>import json\nfrom pathlib import Path\n\nfrom pyglaze.device import Interval, LeDeviceConfiguration\nfrom pyglaze.scanning import GlazeClient\n\ndevice_config = LeDeviceConfiguration(\n    amp_port=\"mock_device\",\n    integration_periods=10,\n    scan_intervals=[\n        Interval(0.5, 1.0),\n        Interval(1.0, 0.0),\n        Interval(0.0, 0.5),\n    ],\n)\n</code></pre> When defining the configuration, a list of <code>scan_intervals</code> is set, determining which parts of the available timewindow should be scanned. Here, we scan a triangular waveform. Next, let's perform a scan.</p> <pre><code>with GlazeClient(config=device_config) as client:\n    scans = client.read(n_pulses=1)\n    pulses = [\n        pulse.from_triangular_waveform(ramp=\"down\")\n        .reconstruct(method=\"cubic_spline\")\n        .as_pulse()\n        for pulse in scans\n    ]\n</code></pre> <p>The client returns a list of <code>UnprocessedWaveform</code>, which can have many shapes and forms depending on the <code>scan_intervals</code>. Here, we extract the part of the waveforms corresponding to the down-ramp of the triangular waveform, then we perform a reconstruction to ensure we have pulses with equidistant times. Finally, having preprocessed the waveforms, we convert it to a list of<code>Pulse</code>. The pulse has attributes such as <code>pulse.time</code>, <code>pulse.signal</code>, <code>pulse.frequency</code> and <code>pulse.fft</code> in addition to many different convenience methods such as <code>pulse.filter()</code> for applying low- and highpass fitlers, <code>pulse.spectrum_dB()</code> for calculating the spectrum on a dB-scale and <code>pulse.to_native_dict()</code> for e.g. saving the pulse. Finally, we'll use the latter to save the results to disk</p> <pre><code>with Path(\"scan_result.json\").open(\"w\") as f:\n    json.dump([pulse.to_native_dict() for pulse in pulses], f, indent=4)\n</code></pre>"},{"location":"#scanner","title":"Scanner","text":"<p>Much like the <code>GlazeClient</code>, a <code>Scanner</code>is instantiated by first defining a configuration. Once instantiated, scans can be acquired by calling the <code>scanner.scan()</code> method.</p> <p><pre><code>import json\nfrom pathlib import Path\n\nfrom pyglaze.device import Interval, LeDeviceConfiguration\nfrom pyglaze.scanning import Scanner\n\ndevice_config = LeDeviceConfiguration(\n    amp_port=\"mock_device\",\n    integration_periods=10,\n    n_points=100,\n    scan_intervals=[\n        Interval(0.5, 1.0),\n        Interval(1.0, 0.0),\n        Interval(0.0, 0.5),\n    ],\n)\n\nscanner = Scanner(config=device_config)\ndevice_config = LeDeviceConfiguration(\n    amp_port=\"mock_device\",\n    integration_periods=10,\n    scan_intervals=[\n        Interval(0.5, 1.0),\n        Interval(1.0, 0.0),\n        Interval(0.0, 0.5),\n    ],\n)\nwaveform = scanner.scan()\npulse = (\n    waveform.from_triangular_waveform(ramp=\"down\")\n    .reconstruct(method=\"cubic_spline\")\n    .as_pulse()\n)\n</code></pre> Like before, the pulse is now ready for further analysis or for saving to disk.</p> <pre><code>with Path(\"scan_result_scanner.json\").open(\"w\") as f:\n    json.dump(pulse.to_native_dict(), f, indent=4)\n</code></pre>"},{"location":"working_without_hardware/","title":"Working without Hardware (Mock Device)","text":"<p>Pyglaze ships with a built\u2011in mock device that produces synthetic data identical in shape and units to what you would receive from a physical Glaze device. This makes it possible to develop, unit\u2011test, or demonstrate software even when no hardware is connected.</p> <p>Quick\u2011start To mock the asynchronous scanner, use <pre><code>from pyglaze.device import LeDeviceConfiguration\nfrom pyglaze.scanning import GlazeClient\n\n# Use the string \"mock_device\" for `amp_port`\nmock_cfg = LeDeviceConfiguration(amp_port=\"mock_device\")\nwith GlazeClient(mock_cfg) as client:\n    pulses = client.read(n_pulses=1)\n</code></pre></p> <p>To use the synchronous scanner, use <pre><code>from pyglaze.device import LeDeviceConfiguration\nfrom pyglaze.scanning import Scanner\n\n# Use the string \"mock_device\" for `amp_port`\nmock_cfg = LeDeviceConfiguration(amp_port=\"mock_device\")\nscanner = Scanner(config=mock_cfg)\nwaveform = scanner.scan()\n</code></pre></p>"},{"location":"working_without_hardware/#1-when-to-use-the-mock-device","title":"1\u00a0\u00a0When to use the mock device","text":"Scenario Benefit Algorithm development Iterate on processing pipelines without reserving lab time. Continuous integration Run the full test\u2011suite on CI servers that have no USB access. Workshops &amp; demos Teach new users the API anywhere, even on a plane. Bug reports Supply a minimal, reproducible script that others can run without hardware."},{"location":"working_without_hardware/#2-how-it-works","title":"2\u00a0\u00a0How it works","text":"<ul> <li>The sentinel string <code>\"mock_device\"</code> instructs Pyglaze to replace the serial driver with a software stub.</li> <li>All higher\u2011level classes (<code>Scanner</code>, <code>GlazeClient</code>, <code>Pulse</code>, <code>UnprocessedWaveform</code>, \u2026) operate unchanged.</li> </ul>"},{"location":"working_without_hardware/#3-common-pitfalls","title":"3\u00a0\u00a0Common pitfalls","text":"<ol> <li>Misspelling the sentinel \u2013 the string is case\u2011sensitive. Use exactly <code>\"mock_device\"</code>.</li> <li>Mistaking it for a placeholder \u2013 it is the implementation, not an example to replace.</li> </ol>"},{"location":"working_without_hardware/#4-search-keywords","title":"4\u00a0\u00a0Search keywords","text":"<ul> <li>simulate / simulation</li> <li>virtual device</li> <li>offline mode</li> <li>no hardware</li> <li>CI pipeline</li> <li>test without device</li> </ul>"},{"location":"API%20Reference/datamodels/Pulse/","title":"Pulse","text":"<p><code>pyglaze.datamodels.Pulse</code></p> <p>Data class for a THz pulse. The pulse is expected to be preprocessed such that times are uniformly spaced.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>FloatArray</code> <p>The time values recorded by the lock-in amp during the scan.</p> required <code>signal</code> <code>FloatArray</code> <p>The signal values recorded by the lock-in amp during the scan.</p> required"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.center_frequency","title":"<code>center_frequency</code>  <code>property</code>","text":"<p>The frequency of the pulse with the highest spectral desnity.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.delay_at_max","title":"<code>delay_at_max</code>  <code>property</code>","text":"<p>Time delay at the maximum value of the pulse.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.delay_at_min","title":"<code>delay_at_min</code>  <code>property</code>","text":"<p>Time delay at the minimum value of the pulse.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.df","title":"<code>df</code>  <code>property</code>","text":"<p>Frequency spacing.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.dt","title":"<code>dt</code>  <code>property</code>","text":"<p>Time spacing.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.energy","title":"<code>energy</code>  <code>property</code>","text":"<p>Energy of the pulse.</p> <p>Note that the energy is not the same as the physical energy of the pulse, but rather the integral of the square of the pulse.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.fft","title":"<code>fft</code>  <code>property</code>","text":"<p>Return the Fourier Transform of a signal.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.frequency","title":"<code>frequency</code>  <code>property</code>","text":"<p>Return the Fourier Transform sample frequencies.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.maximum_spectral_density","title":"<code>maximum_spectral_density</code>  <code>property</code>","text":"<p>The maximum spectral density of the pulse.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.sampling_freq","title":"<code>sampling_freq</code>  <code>property</code>","text":"<p>The sampling frequency in Hz of the scan.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.time_window","title":"<code>time_window</code>  <code>property</code>","text":"<p>The scan time window size in seconds.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.__eq__","title":"<code>__eq__(obj)</code>","text":"<p>Check if two pulses are equal.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.__hash__","title":"<code>__hash__()</code>","text":"<p>Return a hash based on the contents of <code>time</code> and <code>signal</code>.</p> <p>The hash combines shape, dtype and raw bytes of both arrays, ensuring that two :class:<code>Pulse</code> instances that compare equal also have identical hashes.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.add_white_noise","title":"<code>add_white_noise(noise_std, seed=None)</code>","text":"<p>Adds Gaussian noise to each timedomain measurements with a standard deviation given by <code>noise_std</code>.</p> <p>Parameters:</p> Name Type Description Default <code>noise_std</code> <code>float</code> <p>noise standard deviation</p> required <code>seed</code> <code>int | None</code> <p>Seed for the random number generator. If none, a random seed is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>Pulse</code> <p>Pulse with noise</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.align","title":"<code>align(scans, *, wrt_max=True, translate_to_zero=True)</code>  <code>classmethod</code>","text":"<p>Aligns a list of pulses with respect to the zerocrossings of their main pulse.</p> <p>Parameters:</p> Name Type Description Default <code>scans</code> <code>list[Pulse]</code> <p>List of scans</p> required <code>wrt_max</code> <code>bool</code> <p>Whether to perform rough alignment with respect to their maximum (true) or minimum(false). Defaults to True.</p> <code>True</code> <code>translate_to_zero</code> <code>bool</code> <p>Whether to translate all scans to t[0] = 0. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[Pulse]</code> <p>list[Pulse]: Aligned scans.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.average","title":"<code>average(scans)</code>  <code>classmethod</code>","text":"<p>Creates a Pulse object containing the average scan from a list of scans along with uncertainties. Errors are calculated as the standard errors on the means.</p> <p>Parameters:</p> Name Type Description Default <code>scans</code> <code>list[Pulse]</code> <p>List of scans to calculate average from</p> required"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.cut","title":"<code>cut(from_time, to_time)</code>","text":"<p>Create a Pulse object by cutting out a specific section of the scan.</p> <p>Parameters:</p> Name Type Description Default <code>from_time</code> <code>float</code> <p>Time in seconds where cut should be made from</p> required <code>to_time</code> <code>float</code> <p>Time in seconds where cut should be made to</p> required"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.derivative","title":"<code>derivative()</code>","text":"<p>Calculates the derivative of the pulse.</p> <p>Returns:</p> Name Type Description <code>Pulse</code> <code>Pulse</code> <p>New Pulse object containing the derivative</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.downsample","title":"<code>downsample(max_frequency)</code>","text":"<p>Downsamples the pulse by inverse Fourier transforming the spectrum cut at the supplied <code>max_frequency</code>.</p> <p>Parameters:</p> Name Type Description Default <code>max_frequency</code> <code>float</code> <p>Maximum frequency bin after downsampling</p> required <p>Returns:</p> Name Type Description <code>Pulse</code> <code>Pulse</code> <p>Downsampled pulse</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.estimate_SNR","title":"<code>estimate_SNR(linear_segments=1)</code>","text":"<p>Estimates the signal-to-noise ratio.</p> <p>Estimates the SNR, assuming white noise. The noisefloor is estimated by modelling the log of the pulse's spectrum above the center frequency as a constant noisefloor and n linear segments of equal size. Noise power is then calculated as the mean of the absolute square of the spectral bins above the frequency at which the noise floor is reached. The signal power is then extrapolated above the bandwidth by fitting a second order polynomial to the spectrum above the noisefloor.</p> <p>Parameters:</p> Name Type Description Default <code>linear_segments</code> <code>int</code> <p>Number of linear segments to fit to the spectrum. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>float</code> <code>FloatArray</code> <p>Estimated signal-to-noise ratio.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.estimate_avg_noise_power","title":"<code>estimate_avg_noise_power(linear_segments=1)</code>","text":"<p>Estimates the noise power.</p> <p>The noise power is estimated by modelling the the log of pulse's spectrum above the center frequency as a constant noisefloor and n linear segments of equal size. Noise power is then calculated as the mean of the absolute square of the spectral bins above the frequency at which the noise floor is reached.</p> <p>Parameters:</p> Name Type Description Default <code>linear_segments</code> <code>int</code> <p>Number of linear segments to fit to the spectrum. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Estimated noise power.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.estimate_bandwidth","title":"<code>estimate_bandwidth(linear_segments=1)</code>","text":"<p>Estimates the bandwidth of the pulse.</p> <p>The bandwidth is estimated by modelling the log of the pulse's spectrum above the center frequency as a constant noisefloor and n linear segments of equal size. The bandwidth is then defined as the frequency at which the noisefloor is reached.</p> <p>Parameters:</p> Name Type Description Default <code>linear_segments</code> <code>int</code> <p>Number of linear segments to fit to the spectrum. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Estimated bandwidth in Hz</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.estimate_dynamic_range","title":"<code>estimate_dynamic_range(linear_segments=1)</code>","text":"<p>Estimates the dynamic range of the pulse.</p> <p>The dynamic range is estimated by modelling the log of the pulse's spectrum above the center frequency as a constant noisefloor and n linear segments of equal size. The dynamic range is then calculated as the maximum of the spectrum minus the noisefloor.</p> <p>Parameters:</p> Name Type Description Default <code>linear_segments</code> <code>int</code> <p>Number of linear segments to fit to the spectrum. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Estimated dynamic range in dB</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.estimate_peak_to_peak","title":"<code>estimate_peak_to_peak(delay_tolerance=None, strategy=ws_interpolate)</code>","text":"<p>Estimates the peak-to-peak value of the pulse.</p> <p>If a delay tolerance is provided, the peak-to-peak value is estimated by interpolating the pulse at the maximum and minimum values such that the minimum and maximum values of the pulse fall within the given delay tolerance. A lower tolerance will give a more accurate estimate.</p> <p>Parameters:</p> Name Type Description Default <code>delay_tolerance</code> <code>float | None</code> <p>Tolerance for peak detection. Defaults to None.</p> <code>None</code> <code>strategy</code> <code>Callable[[FloatArray, FloatArray, FloatArray], FloatArray]</code> <p>Interpolation strategy. Defaults to Whittaker-Shannon interpolation</p> <code>ws_interpolate</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Estimated peak-to-peak value.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.estimate_zero_crossing","title":"<code>estimate_zero_crossing()</code>","text":"<p>Estimates the zero crossing of the pulse between the maximum and minimum value.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Estimated zero crossing.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.fft_at_f","title":"<code>fft_at_f(f)</code>","text":"<p>Returns the Fourier Transform at a specific frequency.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>float</code> <p>Frequency in Hz</p> required <p>Returns:</p> Name Type Description <code>complex</code> <code>complex</code> <p>Fourier Transform at the given frequency</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.filter","title":"<code>filter(filtertype, cutoff, order)</code>","text":"<p>Applies a highpass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>filtertype</code> <code>Literal['highpass', 'lowpass']</code> <p>Type of filter</p> required <code>cutoff</code> <code>float</code> <p>Frequency, where the filter response has dropped 3 dB</p> required <code>order</code> <code>int</code> <p>Order of the highpass filter</p> required <p>Returns:</p> Type Description <code>Pulse</code> <p>Highpassed pulse</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.from_dict","title":"<code>from_dict(d)</code>  <code>classmethod</code>","text":"<p>Create a Pulse object from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict[str, FloatArray | list[float] | None]</code> <p>A dictionary containing the keys 'time', 'signal'.</p> required"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.from_fft","title":"<code>from_fft(time, fft)</code>  <code>classmethod</code>","text":"<p>Creates a Pulse object from an array of times and a Fourier spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>FloatArray</code> <p>Time series of pulse related to the Fourier spectrum</p> required <code>fft</code> <code>ComplexArray</code> <p>Fourier spectrum of pulse</p> required"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.propagate","title":"<code>propagate(time)</code>","text":"<p>Propagates the pulse in time by a given amount.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>Time in seconds to propagate the pulse by</p> required <p>Returns:</p> Name Type Description <code>Pulse</code> <code>Pulse</code> <p>Propagated pulse</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.signal_at_t","title":"<code>signal_at_t(t)</code>","text":"<p>Returns the signal at a specific time using Whittaker Shannon interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Time in seconds</p> required <p>Returns:</p> Type Description <code>float</code> <p>Signal at the given time</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.spectrum_dB","title":"<code>spectrum_dB(reference=None, offset_ratio=None)</code>","text":"<p>Calculates the spectral density in decibel.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>float | None</code> <p>Reference spectral amplitude. If none, the maximum of the FFT is used.</p> <code>None</code> <code>offset_ratio</code> <code>float | None</code> <p>Offset in decibel relative to the maximum of the FFT to avoid taking the logarithm of 0. If none, no offset is applied.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FloatArray</code> <code>FloatArray</code> <p>Spectral density in decibel</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.subtract_mean","title":"<code>subtract_mean(fraction=0.99)</code>","text":"<p>Subtracts the mean of the pulse.</p> <p>Parameters:</p> Name Type Description Default <code>fraction</code> <code>float</code> <p>Fraction of the mean to subtract. Defaults to 0.99.</p> <code>0.99</code> <p>Returns:</p> Type Description <code>Pulse</code> <p>Pulse with the mean subtracted</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.timeshift","title":"<code>timeshift(scale, offset=0)</code>","text":"<p>Rescales and offsets the time axis as.</p> <p>new_times = scale*(t + offset)</p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>float</code> <p>Rescaling factor</p> required <code>offset</code> <code>float</code> <p>Offset. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>Pulse</code> <p>Timeshifted pulse</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.to_native_dict","title":"<code>to_native_dict()</code>","text":"<p>Converts the Pulse object to a native dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, list[float] | None]</code> <p>Native dictionary representation of the Pulse object.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.tukey","title":"<code>tukey(taper_length, from_time=None, to_time=None)</code>","text":"<p>Applies a Tukey window and returns a new Pulse object - see https://en.wikipedia.org/wiki/Window_function.</p> <p>Parameters:</p> Name Type Description Default <code>taper_length</code> <code>float</code> <p>Length in seconds of the cosine tapering length, i.e. half a cosine cycle</p> required <code>from_time</code> <code>float | None</code> <p>Left edge in seconds at which the window becomes 0</p> <code>None</code> <code>to_time</code> <code>float | None</code> <p>Right edge in seconds at which the window becomes 0</p> <code>None</code>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.zeropadded","title":"<code>zeropadded(n_zeros)</code>","text":"<p>Returns a new, zero-padded pulse.</p> <p>Parameters:</p> Name Type Description Default <code>n_zeros</code> <code>int</code> <p>number of zeros to add</p> required <p>Returns:</p> Type Description <code>Pulse</code> <p>Zero-padded pulse</p>"},{"location":"API%20Reference/datamodels/Pulse/#notes","title":"Notes","text":"<p>The lock-in amp outputs \\(\\left( r, \\theta \\right)\\) values. To get useful readings, one must convert these readings by</p> \\[ r \\operatorname{sgn} (\\theta - 180). \\] <p>\\(\\operatorname{sgn}\\), the so-called signum function outputs the signs of a vector in a piecewise fashion, implemented in NumPy using</p> \\[ \\operatorname{sgn} = \\frac{x}{\\sqrt{x^2}}. \\] <p>This is handled by the <code>ScanData</code> class, and is done transparently when using <code>pyglaze.scanning.scanner.Scanner</code>. If you have a previous reading that has been converted, <code>ScanData</code> allows you to create an object from this data in dictionary form; see examples below.</p>"},{"location":"API%20Reference/datamodels/Pulse/#examples","title":"Examples","text":"From JSON file <pre><code>import json\nfrom pathlib import Path\n\nimport numpy as np\n\nfrom pyglaze.datamodels import Pulse\n\n# Generate a pulse - would typically be done with an actual THz device\nnew_pulse = Pulse(\n    time=np.linspace(0, 1, 100), signal=np.random.default_rng().normal(size=100)\n)\n\n# Save the pulse as a JSON file\nwith Path(\"my_pulse_data.json\").open(\"w\") as f:\n    json.dump(new_pulse.to_native_dict(), f)\n\n# Load the pulse from the JSON file again\nwith Path(\"my_pulse_data.json\").open() as f:\n    run_data = json.load(f)\n\npulse = Pulse.from_dict(d=run_data)\n</code></pre>"},{"location":"API%20Reference/datamodels/UnprocessedWaveform/","title":"UnprocessedWaveform","text":"<p><code>pyglaze.datamodels.UnprocessedWaveform</code></p> <p>A dataclass representing an unprocessed waveform. No assumptions are made about the delay or signal.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>FloatArray</code> <p>The time values recorded by the lock-in amp during the scan.</p> required <code>signal</code> <code>FloatArray</code> <p>The signal values recorded by the lock-in amp during the scan.</p> required"},{"location":"API%20Reference/datamodels/UnprocessedWaveform/#pyglaze.datamodels.UnprocessedWaveform.as_pulse","title":"<code>as_pulse()</code>","text":"<p>Converts the current waveform to a Pulse object.</p>"},{"location":"API%20Reference/datamodels/UnprocessedWaveform/#pyglaze.datamodels.UnprocessedWaveform.average","title":"<code>average(waveforms)</code>  <code>classmethod</code>","text":"<p>Computes the average of a list of UnprocessedWaveform objects.</p> <p>Parameters:</p> Name Type Description Default <code>waveforms</code> <code>list[UnprocessedWaveform]</code> <p>List of waveforms</p> required"},{"location":"API%20Reference/datamodels/UnprocessedWaveform/#pyglaze.datamodels.UnprocessedWaveform.from_dict","title":"<code>from_dict(d)</code>  <code>classmethod</code>","text":"<p>Create an UnprocessedWaveform object from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict[str, FloatArray | list[float] | None]</code> <p>A dictionary containing the keys 'time', 'signal'.</p> required"},{"location":"API%20Reference/datamodels/UnprocessedWaveform/#pyglaze.datamodels.UnprocessedWaveform.from_polar_coords","title":"<code>from_polar_coords(time, radius, theta, rotation_angle=None)</code>  <code>classmethod</code>","text":"<p>Create an UnprocessedWaveform object from raw lock-in amp output.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>FloatArray</code> <p>The time values recorded by the lock-in amp during the scan.</p> required <code>radius</code> <code>FloatArray</code> <p>The radius values recorded by the lock-in amp during the scan.</p> required <code>theta</code> <code>FloatArray</code> <p>The theta values recorded by the lock-in amp during the scan (in degrees).</p> required <code>rotation_angle</code> <code>float | None</code> <p>The angle to rotate lockin signal to align along x-axis. If not given, will use the angle at the maximum value of R.</p> <code>None</code>"},{"location":"API%20Reference/datamodels/UnprocessedWaveform/#pyglaze.datamodels.UnprocessedWaveform.from_triangular_waveform","title":"<code>from_triangular_waveform(ramp)</code>","text":"<p>Picks out the pulse from a scan with fiberstretchers driven by a triangular waveform.</p> <p>Parameters:</p> Name Type Description Default <code>ramp</code> <code>Literal['up', 'down']</code> <p>Whether to pick out the pulse from the upgoing or downgoing ramp of the triangle wave</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If 'ramp' is neither 'up' or 'down'</p> <p>Returns:</p> Type Description <code>UnprocessedWaveform</code> <p>Raw waveform</p>"},{"location":"API%20Reference/datamodels/UnprocessedWaveform/#pyglaze.datamodels.UnprocessedWaveform.reconstruct","title":"<code>reconstruct(method, times=None)</code>","text":"<p>Reconstructs the waveform for a specified array of times using a specified method. If no delays are given, linearly spaced times between the maximum and the minimum of the delays will be used.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>RecoMethod</code> <p>Name of reconstruction method.</p> required <code>times</code> <code>FloatArray | None</code> <p>Optional array of delay times.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>When an unknown reconstruction method is requested</p>"},{"location":"API%20Reference/device/LeDeviceConfiguration/","title":"LeDeviceConfiguration","text":"<p><code>pyglaze.device.LeDeviceConfiguration</code></p> <p>               Bases: <code>DeviceConfiguration</code></p> <p>Represents a configuration that can be sent to a Le-type lock-in amp for scans.</p> <p>Parameters:</p> Name Type Description Default <code>amp_port</code> <code>str</code> <p>The name of the serial port the amp is connected to.</p> required <code>use_ema</code> <code>bool</code> <p>Whether to use en exponentially moving average filter during lockin detection.</p> <code>True</code> <code>n_points</code> <code>int</code> <p>The number of points to scan.</p> <code>1000</code> <code>scan_intervals</code> <code>list[Interval]</code> <p>The intervals to scan.</p> <code>lambda: [Interval(0.0, 1.0)]()</code> <code>integration_periods</code> <code>int</code> <p>The number of integration periods per datapoint to use.</p> <code>10</code> <code>amp_timeout_seconds</code> <code>float</code> <p>The timeout for the connection to the amp in seconds.</p> <code>0.2</code>"},{"location":"API%20Reference/device/LeDeviceConfiguration/#pyglaze.device.LeDeviceConfiguration.from_dict","title":"<code>from_dict(amp_config)</code>  <code>classmethod</code>","text":"<p>Create a LeDeviceConfiguration from a dict.</p> <p>Parameters:</p> Name Type Description Default <code>amp_config</code> <code>dict</code> <p>An amp configuration in dict form.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the dictionary is empty.</p> <p>Returns:</p> Name Type Description <code>DeviceConfiguration</code> <code>LeDeviceConfiguration</code> <p>A DeviceConfiguration object.</p>"},{"location":"API%20Reference/device/LeDeviceConfiguration/#pyglaze.device.LeDeviceConfiguration.load","title":"<code>load(file_path)</code>  <code>classmethod</code>","text":"<p>Load a LeDeviceConfiguration from a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>The path to the file to load.</p> required <p>Returns:</p> Name Type Description <code>DeviceConfiguration</code> <code>LeDeviceConfiguration</code> <p>A DeviceConfiguration object.</p>"},{"location":"API%20Reference/device/LeDeviceConfiguration/#pyglaze.device.LeDeviceConfiguration.save","title":"<code>save(path)</code>","text":"<p>Save a LeDeviceConfiguration to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to save the configuration to.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Final path component of the saved file, without the extension.</p>"},{"location":"API%20Reference/device/LeDeviceConfiguration/#examples","title":"Examples","text":""},{"location":"API%20Reference/device/LeDeviceConfiguration/#make-a-device-configuration","title":"Make a device configuration","text":"<p>Depending on which device is used, a matching device configuration must be used.</p> Make a device configuration <pre><code>from pyglaze.device import LeDeviceConfiguration\n\nconfig = LeDeviceConfiguration(\n    amp_port=\"mock_device\", use_ema=True\n)\n</code></pre> <p>Be sure to use the correct port and delayunit! The <code>mock_device</code> and <code>mock_delay</code> are only for testing purposes</p>"},{"location":"API%20Reference/scanning/GlazeClient/","title":"GlazeClient","text":"<p><code>pyglaze.scanning.GlazeClient</code></p> <p>Warning</p> <p>Ensure that you are properly connected to the lock-in amp, have it selected, and a configuration is chosen.</p> <p>Open a connection to and start continuously scanning using the Glaze device.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>DeviceConfiguration</code> <p>Configuration to use for scans</p> required"},{"location":"API%20Reference/scanning/GlazeClient/#pyglaze.scanning.GlazeClient.__enter__","title":"<code>__enter__()</code>","text":"<p>Start the scanner and return the client.</p>"},{"location":"API%20Reference/scanning/GlazeClient/#pyglaze.scanning.GlazeClient.__exit__","title":"<code>__exit__(*args)</code>","text":"<p>Stop the scanner and close the connection.</p>"},{"location":"API%20Reference/scanning/GlazeClient/#pyglaze.scanning.GlazeClient.get_firmware_version","title":"<code>get_firmware_version()</code>","text":"<p>Get the firmware version of the connected device.</p>"},{"location":"API%20Reference/scanning/GlazeClient/#pyglaze.scanning.GlazeClient.get_serial_number","title":"<code>get_serial_number()</code>","text":"<p>Get the serial number of the connected device.</p>"},{"location":"API%20Reference/scanning/GlazeClient/#pyglaze.scanning.GlazeClient.read","title":"<code>read(n_pulses)</code>","text":"<p>Read a number of pulses from the Glaze system.</p> <p>Parameters:</p> Name Type Description Default <code>n_pulses</code> <code>int</code> <p>The number of terahertz pulses to read from the CCS server.</p> required"},{"location":"API%20Reference/scanning/GlazeClient/#examples","title":"Examples","text":"Initialize a Scanner and perform two scans<pre><code>from pyglaze.device import LeDeviceConfiguration\nfrom pyglaze.scanning import GlazeClient\n\n\ndef main() -&gt; None:\n    n_pulses = 2\n    device_config = LeDeviceConfiguration(\n        amp_port=\"mock_device\", delayunit=\"mock_delay\"\n    )\n    with GlazeClient(device_config) as client:\n        unprocessed_waveforms = client.read(n_pulses=n_pulses)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <ol> <li>The config file should be valid JSON of the <code>DeviceConfiguration</code> type. See a list of configuration options under \"API Reference &gt; Device\".</li> </ol>"},{"location":"API%20Reference/scanning/Scanner/","title":"Scanner","text":"<p><code>pyglaze.scanning.Scanner</code></p> <p>A synchronous scanner for Glaze terahertz devices.</p>"},{"location":"API%20Reference/scanning/Scanner/#pyglaze.scanning.Scanner.config","title":"<code>config</code>  <code>property</code> <code>writable</code>","text":"<p>Configuration used in the scan.</p>"},{"location":"API%20Reference/scanning/Scanner/#pyglaze.scanning.Scanner.disconnect","title":"<code>disconnect()</code>","text":"<p>Close serial connection.</p>"},{"location":"API%20Reference/scanning/Scanner/#pyglaze.scanning.Scanner.get_firmware_version","title":"<code>get_firmware_version()</code>","text":"<p>Get the firmware version of the connected device.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The firmware version of the connected device.</p>"},{"location":"API%20Reference/scanning/Scanner/#pyglaze.scanning.Scanner.get_serial_number","title":"<code>get_serial_number()</code>","text":"<p>Get the serial number of the connected device.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The serial number of the connected device.</p>"},{"location":"API%20Reference/scanning/Scanner/#pyglaze.scanning.Scanner.scan","title":"<code>scan()</code>","text":"<p>Perform a scan.</p> <p>Returns:</p> Name Type Description <code>UnprocessedWaveform</code> <code>UnprocessedWaveform</code> <p>A raw waveform.</p>"},{"location":"API%20Reference/scanning/Scanner/#pyglaze.scanning.Scanner.update_config","title":"<code>update_config(new_config)</code>","text":"<p>Update the DeviceConfiguration used in the scan.</p> <p>Parameters:</p> Name Type Description Default <code>new_config</code> <code>DeviceConfiguration</code> <p>New configuration for scanner</p> required"},{"location":"API%20Reference/scanning/Scanner/#examples","title":"Examples","text":""},{"location":"API%20Reference/scanning/Scanner/#initialize-a-scanner-and-perform-a-scan","title":"Initialize a Scanner and perform a scan","text":"<p>The config file should be valid JSON conforming to the specific <code>DeviceConfiguration</code> type. See e.g. a definition here. Be sure to replace <code>mock_device</code> and <code>mock_delay</code> with suitable values.</p> LeDeviceConfiguration <pre><code>from pyglaze.device import LeDeviceConfiguration\nfrom pyglaze.scanning import Scanner\n\ndevice_config = LeDeviceConfiguration(amp_port=\"mock_device\")\nscanner = Scanner(config=device_config)\nscan_result = scanner.scan()\n</code></pre>"}]}