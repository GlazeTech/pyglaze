{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Pyglaze","text":"<p>Source Code: https://github.com/GlazeTech/pyglaze</p> <p>Documentation Version: 0.1.1</p> <p>This is the Pyglaze API documentation. Pyglaze is a python library used to operate the devices of Glaze Technologies. If you have a feature request or discover a bug, please create an issue here and we will look at it ASAP!</p>"},{"location":"#usage","title":"Usage","text":"<p>Pyglaze provides two main interfaces for operating Glaze devices: The <code>Scanner</code> and the The <code>GlazeClient</code>, where <code>Scanner</code>is a synchronous scanner, only scanning when requested, and <code>GlazeClient</code> is an asynchronous scanner, continuously scanning in the background.</p>"},{"location":"#glazeclient","title":"GlazeClient","text":"<p>Using the <code>GlazeClient</code>is the prefered way to acquire scans. Before starting the scanner, a device configuration must be created. Depending on the type of device, different configurations are required, see e.g. a definition here or here. Be sure to replace <code>mock_device</code> and <code>mock_delay</code> with suitable values. Here, we will use a <code>LeDeviceConfiguration</code>.</p> <p><pre><code>import json\nfrom pathlib import Path\n\nfrom pyglaze.device import Interval, LeDeviceConfiguration\nfrom pyglaze.scanning import GlazeClient\n\ndevice_config = LeDeviceConfiguration(\n    amp_port=\"mock_device\",\n    delayunit=\"mock_delay\",\n    integration_periods=10,\n    scan_intervals=[\n        Interval(0.5, 1.0),\n        Interval(1.0, 0.0),\n        Interval(0.0, 0.5),\n    ],\n)\n</code></pre> When defining the configuration, a list of <code>scan_intervals</code> is set, determining which parts of the available timewindow should be scanned. Here, we scan a triangular waveform. Next, let's perform a scan.</p> <pre><code>with GlazeClient(config=device_config) as client:\n    scans = client.read(n_pulses=1)\n    pulses = [\n        pulse.from_triangular_waveform(ramp=\"down\")\n        .reconstruct(method=\"cubic_spline\")\n        .as_pulse()\n        for pulse in scans\n    ]\n</code></pre> <p>The client returns a list of <code>UnprocessedWaveform</code>, which can have many shapes and forms depending on the <code>scan_intervals</code>. Here, we extract the part of the waveforms corresponding to the down-ramp of the triangular waveform, then we perform a reconstruction to ensure we have pulses with equidistant times. Finally, having preprocessed the waveforms, we convert it to a list of<code>Pulse</code>. The pulse has attributes such as <code>pulse.time</code>, <code>pulse.signal</code>, <code>pulse.frequency</code> and <code>pulse.fft</code> in addition to many different convenience methods such as <code>pulse.filter()</code> for applying low- and highpass fitlers, <code>pulse.spectrum_dB()</code> for calculating the spectrum on a dB-scale and <code>pulse.to_native_dict()</code> for e.g. saving the pulse. Finally, we'll use the latter to save the results to disk</p> <pre><code>with Path(\"scan_result.json\").open(\"w\") as f:\n    json.dump([pulse.to_native_dict() for pulse in pulses], f, indent=4)\n</code></pre>"},{"location":"#scanner","title":"Scanner","text":"<p>Much like the <code>GlazeClient</code>, a <code>Scanner</code>is instantiated by first defining a configuration. Once instantiated, scans can be acquired by calling the <code>scanner.scan()</code> method.</p> <p><pre><code>import json\nfrom pathlib import Path\n\nfrom pyglaze.device import Interval, LeDeviceConfiguration\nfrom pyglaze.scanning import Scanner\n\ndevice_config = LeDeviceConfiguration(\n    amp_port=\"mock_device\",\n    delayunit=\"mock_delay\",\n    integration_periods=10,\n    n_points=100,\n    scan_intervals=[\n        Interval(0.5, 1.0),\n        Interval(1.0, 0.0),\n        Interval(0.0, 0.5),\n    ],\n)\n\nscanner = Scanner(config=device_config)\ndevice_config = LeDeviceConfiguration(\n    amp_port=\"mock_device\",\n    delayunit=\"mock_delay\",\n    integration_periods=10,\n    scan_intervals=[\n        Interval(0.5, 1.0),\n        Interval(1.0, 0.0),\n        Interval(0.0, 0.5),\n    ],\n)\nwaveform = scanner.scan()\npulse = (\n    waveform.from_triangular_waveform(ramp=\"down\")\n    .reconstruct(method=\"cubic_spline\")\n    .as_pulse()\n)\n</code></pre> Like before, the pulse is now ready for further analysis or for saving to disk.</p> <pre><code>with Path(\"scan_result_scanner.json\").open(\"w\") as f:\n    json.dump(pulse.to_native_dict(), f, indent=4)\n</code></pre>"},{"location":"API%20Reference/datamodels/Pulse/","title":"Pulse","text":"<p><code>pyglaze.datamodels.Pulse</code></p> <p>Data class for a THz pulse. The pulse is expected to be preprocessed such that times are uniformly spaced.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>FloatArray</code> <p>The time values recorded by the lock-in amp during the scan.</p> required <code>signal</code> <code>FloatArray</code> <p>The signal values recorded by the lock-in amp during the scan.</p> required <code>signal_err</code> <code>FloatArray | None</code> <p>Potential errors on signal</p> <code>None</code> Source code in <code>src/pyglaze/datamodels/pulse.py</code> <pre><code>@dataclass\nclass Pulse:\n    \"\"\"Data class for a THz pulse. The pulse is expected to be preprocessed such that times are uniformly spaced.\n\n    Args:\n        time: The time values recorded by the lock-in amp during the scan.\n        signal: The signal values recorded by the lock-in amp during the scan.\n        signal_err: Potential errors on signal\n    \"\"\"\n\n    time: FloatArray\n    signal: FloatArray\n    signal_err: FloatArray | None = None\n\n    def __len__(self: Pulse) -&gt; int:  # noqa: D105\n        return len(self.time)\n\n    def __eq__(self: Pulse, obj: object) -&gt; bool:\n        \"\"\"Check if two pulses are equal.\"\"\"\n        if not isinstance(obj, Pulse):\n            return False\n\n        return bool(\n            np.array_equal(self.time, obj.time)\n            and np.array_equal(self.signal, obj.signal)\n            and np.array_equal(self.signal_err, obj.signal_err)  # type: ignore[arg-type]\n        )\n\n    @cached_property\n    def fft(self: Pulse) -&gt; ComplexArray:\n        \"\"\"Return the Fourier Transform of a signal.\"\"\"\n        return np.fft.rfft(self.signal, norm=\"forward\")\n\n    @cached_property\n    def frequency(self: Pulse) -&gt; FloatArray:\n        \"\"\"Return the Fourier Transform sample frequencies.\"\"\"\n        return np.fft.rfftfreq(len(self.signal), d=self.time[1] - self.time[0])\n\n    @property\n    def time_window(self: Pulse) -&gt; float:\n        \"\"\"The scan time window size in seconds.\"\"\"\n        return float(self.time[-1] - self.time[0])\n\n    @property\n    def sampling_freq(self: Pulse) -&gt; float:\n        \"\"\"The sampling frequency in Hz of the scan.\"\"\"\n        return float(1 / (self.time[1] - self.time[0]))\n\n    @property\n    def dt(self: Pulse) -&gt; float:\n        \"\"\"Time spacing.\"\"\"\n        return float(self.time[1] - self.time[0])\n\n    @property\n    def df(self: Pulse) -&gt; float:\n        \"\"\"Frequency spacing.\"\"\"\n        return float(self.frequency[1] - self.frequency[0])\n\n    @property\n    def center_frequency(self: Pulse) -&gt; float:\n        \"\"\"The frequency of the pulse with the highest spectral desnity.\"\"\"\n        return float(self.frequency[np.argmax(np.abs(self.fft))])\n\n    @property\n    def maximum_spectral_density(self: Pulse) -&gt; float:\n        \"\"\"The maximum spectral density of the pulse.\"\"\"\n        return float(np.max(np.abs(self.fft)))\n\n    @property\n    def delay_at_max(self: Pulse) -&gt; float:\n        \"\"\"Time delay at the maximum value of the pulse.\"\"\"\n        return float(self.time[np.argmax(self.signal)])\n\n    @property\n    def delay_at_min(self: Pulse) -&gt; float:\n        \"\"\"Time delay at the minimum value of the pulse.\"\"\"\n        return float(self.time[np.argmin(self.signal)])\n\n    @classmethod\n    def from_dict(\n        cls: type[Pulse], d: dict[str, FloatArray | list[float] | None]\n    ) -&gt; Pulse:\n        \"\"\"Create a Pulse object from a dictionary.\n\n        Args:\n            d: A dictionary containing the keys 'time', 'signal' and potentially 'signal_err'.\n        \"\"\"\n        err = (\n            np.array(d[\"signal_err\"]) if type(d.get(\"signal_err\")) is not None else None\n        )\n        return Pulse(\n            time=np.array(d[\"time\"]), signal=np.array(d[\"signal\"]), signal_err=err\n        )\n\n    @classmethod\n    def from_fft(cls: type[Pulse], time: FloatArray, fft: ComplexArray) -&gt; Pulse:\n        \"\"\"Creates a Pulse object from an array of times and a Fourier spectrum.\n\n        Args:\n            time: Time series of pulse related to the Fourier spectrum\n            fft: Fourier spectrum of pulse\n\n        \"\"\"\n        sig = np.fft.irfft(fft, norm=\"forward\", n=len(time), axis=0)\n        return cls(time, sig)\n\n    @classmethod\n    def average(cls: type[Pulse], scans: list[Pulse]) -&gt; Pulse:\n        \"\"\"Creates a Pulse object containing the average scan from a list of scans along with uncertainties. Errors are calculated as the standard errors on the means.\n\n        Args:\n            scans: List of scans to calculate average from\n\n        \"\"\"\n        if len(scans) == 1:\n            return scans[0]\n        signals = np.array([scan.signal for scan in scans])\n        mean_signal = np.mean(signals, axis=0)\n\n        root_n_scans = np.sqrt(len(scans))\n        std_signal = np.std(signals, axis=0, ddof=1) / root_n_scans\n        return Pulse(scans[0].time, mean_signal, signal_err=std_signal)\n\n    @classmethod\n    def align(\n        cls: type[Pulse],\n        scans: list[Pulse],\n        *,\n        wrt_max: bool = True,\n        translate_to_zero: bool = True,\n    ) -&gt; list[Pulse]:\n        \"\"\"Aligns a list of scan with respect to their individual maxima or minima.\n\n        Args:\n            scans: List of scans\n            wrt_max: Whether to align with respect to maximum. Defaults to True.\n            translate_to_zero: Whether to translate all scans to t[0] = 0. Defaults to True.\n\n        Returns:\n            list[Pulse]: Aligned scans.\n        \"\"\"\n        extrema = [scan._get_min_or_max_idx(wrt_max=wrt_max) for scan in scans]  # noqa: SLF001\n        n_before = min(extrema)\n        n_after = min(len(scan) - index - 1 for scan, index in zip(scans, extrema))\n        roughly_aligned = [\n            cls._from_slice(scan, slice(index - n_before, index + n_after))\n            for index, scan in zip(extrema, scans)\n        ]\n\n        if translate_to_zero:\n            for scan in roughly_aligned:\n                scan.time = scan.time - scan.time[0]\n\n        ref = roughly_aligned[len(roughly_aligned) // 2]\n        extremum = extrema[len(roughly_aligned) // 2]\n        return _match_templates(extremum, ref, roughly_aligned)\n\n    @classmethod\n    def _from_slice(cls: type[Pulse], scan: Pulse, indices: slice) -&gt; Pulse:\n        err = scan.signal_err[indices] if scan.signal_err is not None else None\n        return cls(scan.time[indices], scan.signal[indices], err)\n\n    def cut(self: Pulse, from_time: float, to_time: float) -&gt; Pulse:\n        \"\"\"Create a Pulse object by cutting out a specific section of the scan.\n\n        Args:\n            from_time: Time in seconds where cut should be made from\n            to_time: Time in seconds where cut should be made to\n        \"\"\"\n        from_idx = int(np.searchsorted(self.time, from_time))\n        to_idx = int(np.searchsorted(self.time, to_time, side=\"right\"))\n        return Pulse(\n            self.time[from_idx:to_idx],\n            self.signal[from_idx:to_idx],\n            None if self.signal_err is None else self.signal_err[from_idx:to_idx],\n        )\n\n    def timeshift(self: Pulse, scale: float, offset: float = 0) -&gt; Pulse:\n        \"\"\"Rescales and offsets the time axis as.\n\n        new_times = scale*(t + offset)\n\n        Args:\n            scale: Rescaling factor\n            offset: Offset. Defaults to 0.\n\n        Returns:\n            Timeshifted pulse\n        \"\"\"\n        return Pulse(\n            time=scale * (self.time + offset),\n            signal=self.signal,\n            signal_err=self.signal_err,\n        )\n\n    def add_white_noise(\n        self: Pulse, noise_std: float, seed: int | None = None\n    ) -&gt; Pulse:\n        \"\"\"Adds Gaussian noise to each timedomain measurements with a standard deviation given by `noise_std`.\n\n        Args:\n            noise_std: noise standard deviation\n            seed: Seed for the random number generator. If none, a random seed is used.\n\n        Returns:\n            Pulse with noise\n        \"\"\"\n        return Pulse(\n            time=self.time,\n            signal=self.signal\n            + np.random.default_rng(seed).normal(\n                loc=0, scale=noise_std, size=len(self)\n            ),\n            signal_err=np.ones(len(self)) * noise_std,\n        )\n\n    def zeropadded(self: Pulse, n_zeros: int) -&gt; Pulse:\n        \"\"\"Returns a new, zero-padded pulse.\n\n        Args:\n            n_zeros: number of zeros to add\n\n        Returns:\n            Zero-padded pulse\n        \"\"\"\n        zeropadded_signal = np.concatenate((np.zeros(n_zeros), self.signal))\n        zeropadded_time = np.concatenate(\n            (self.time[0] + np.arange(n_zeros, 0, -1) * -self.dt, self.time)\n        )\n        return Pulse(time=zeropadded_time, signal=zeropadded_signal)\n\n    def tukey(\n        self: Pulse,\n        taper_length: float,\n        from_time: float | None = None,\n        to_time: float | None = None,\n    ) -&gt; Pulse:\n        \"\"\"Applies a Tukey window and returns a new Pulse object - see https://en.wikipedia.org/wiki/Window_function.\n\n        Args:\n            taper_length: Length in seconds of the cosine tapering length, i.e. half a cosine cycle\n            from_time: Left edge in seconds at which the window becomes 0\n            to_time: Right edge in seconds at which the window becomes 0\n        \"\"\"\n        N = len(self)\n        _to_time = to_time or self.time[-1]\n        _from_time = from_time or self.time[0]\n        _tukey_window_length = _to_time - _from_time\n\n        # NOTE: See https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.windows.tukey.html#scipy.signal.windows.tukey\n        M = int(N * _tukey_window_length / self.time_window)\n        if M &gt; N:\n            msg = \"Number of points in Tukey window cannot exceed number of points in scan\"\n            raise ValueError(msg)\n        alpha = 2 * taper_length / _tukey_window_length\n        _tukey_window = signal.windows.tukey(M=M, alpha=alpha)\n\n        window = np.zeros(N)\n        from_time_idx = np.searchsorted(self.time, _from_time)\n        window[from_time_idx : M + from_time_idx] = _tukey_window\n\n        return Pulse(self.time, self.signal * window)\n\n    def derivative(self: Pulse) -&gt; Pulse:\n        \"\"\"Calculates the derivative of the pulse.\n\n        Returns:\n            Pulse: New Pulse object containing the derivative\n        \"\"\"\n        return Pulse(time=self.time, signal=np.gradient(self.signal))\n\n    def downsample(self: Pulse, max_frequency: float) -&gt; Pulse:\n        \"\"\"Downsamples the pulse by inverse Fourier transforming the spectrum cut at the supplied `max_frequency`.\n\n        Args:\n            max_frequency: Maximum frequency bin after downsampling\n\n        Returns:\n            Pulse: Downsampled pulse\n        \"\"\"\n        idx = np.searchsorted(self.frequency, max_frequency)\n        new_fft = self.fft[:idx]\n        new_dt = 1 / (2 * self.frequency[:idx][-1])\n        new_times = np.arange(2 * (len(new_fft) - 1)) * new_dt + self.time[0]\n        return Pulse.from_fft(time=new_times, fft=new_fft)\n\n    def filter(\n        self: Pulse,\n        filtertype: Literal[\"highpass\", \"lowpass\"],\n        cutoff: float,\n        order: int,\n    ) -&gt; Pulse:\n        \"\"\"Applies a highpass filter to the signal.\n\n        Args:\n            filtertype: Type of filter\n            cutoff: Frequency, where the filter response has dropped 3 dB\n            order: Order of the highpass filter\n\n        Returns:\n            Highpassed pulse\n        \"\"\"\n        sos = signal.butter(\n            N=order, Wn=cutoff, btype=filtertype, fs=self.sampling_freq, output=\"sos\"\n        )\n        return Pulse(self.time, np.asarray(signal.sosfilt(sos, self.signal)))\n\n    def spectrum_dB(\n        self: Pulse, reference: float | None = None, offset_ratio: float | None = None\n    ) -&gt; FloatArray:\n        \"\"\"Calculates the spectral density in decibel.\n\n        Args:\n            reference: Reference spectral amplitude. If none, the maximum of the FFT is used.\n            offset_ratio: Offset in decibel relative to the maximum of the FFT to avoid taking the logarithm of 0. If none, no offset is applied.\n\n        Returns:\n            FloatArray: Spectral density in decibel\n        \"\"\"\n        abs_spectrum = np.abs(self.fft)\n        offset = 0 if offset_ratio is None else offset_ratio * np.max(abs_spectrum)\n        ref = reference or np.max(abs_spectrum)\n\n        return np.asarray(\n            20 * np.log10((abs_spectrum + offset) / ref), dtype=np.float64\n        )\n\n    def estimate_bandwidth(self: Pulse, omega_power: int = 3) -&gt; float:\n        \"\"\"Estimates the bandwidth of the pulse.\n\n        Uses the approach described in [Algorithm for Determination of Cutoff Frequency of Noise Floor Level for Terahertz Time-Domain Signals](https://doi.org/10.1007/s10762-022-00886-y).\n\n        Args:\n            omega_power: power to raise omega to before estimating the bandwidth. Defaults to 3\n\n        Returns:\n            float: Estimated bandwidth in Hz\n        \"\"\"\n        return self._estimate_pulse_properties(omega_power)[0]\n\n    def estimate_dynamic_range(self: Pulse, omega_power: int = 3) -&gt; float:\n        \"\"\"Estimates the dynamic range of the pulse.\n\n        Uses the approach described in [Algorithm for Determination of Cutoff Frequency of Noise Floor Level for Terahertz Time-Domain Signals](https://doi.org/10.1007/s10762-022-00886-y).\n\n        Args:\n            omega_power: power to raise omega to before estimating the dynamic range. Defaults to 3\n\n        Returns:\n            float: Estimated dynamic range in dB\n        \"\"\"\n        return self._estimate_pulse_properties(omega_power)[1]\n\n    def estimate_avg_noise_power(self: Pulse, omega_power: int = 3) -&gt; float:\n        \"\"\"Estimates the noise power.\n\n        Noise power is defined as the mean of the absolute square of the noise floor.\n        Uses the approach described in [Algorithm for Determination of Cutoff Frequency of Noise Floor Level for Terahertz Time-Domain Signals](https://doi.org/10.1007/s10762-022-00886-y).\n\n        Args:\n            omega_power: power to raise omega to before estimating the noisepower. Defaults to 3\n\n        Returns:\n            float: Estimated noise power.\n        \"\"\"\n        return self._estimate_pulse_properties(omega_power)[2]\n\n    def estimate_SNR(self: Pulse, omega_power: int = 3) -&gt; FloatArray:\n        \"\"\"Estimates the signal-to-noise ratio.\n\n        Estimates the SNR, assuming white noise. Uses the approach described in [Algorithm for Determination of Cutoff Frequency of Noise Floor Level for Terahertz Time-Domain Signals](https://doi.org/10.1007/s10762-022-00886-y) to estimate the noise power. The signal power is then extrapolated above the bandwidth by fitting a second order polynomial to the spectrum above the noisefloor.\n\n        Args:\n            omega_power: power to raise omega to before estimating the signal-to-noise ratio. Defaults to 3\n\n        Returns:\n            float: Estimated signal-to-noise ratio.\n        \"\"\"\n        # Get spectrum between maximum and noisefloor\n        _from = np.argmax(self.spectrum_dB())\n        _to = np.searchsorted(\n            self.frequency, self.estimate_bandwidth(omega_power=omega_power)\n        )\n        x = self.frequency[_from:_to]\n        y = self.spectrum_dB()[_from:_to]\n\n        # Fit a second order polynomial to the spectrum above the noisefloor\n        poly_fit = np.polynomial.Polynomial.fit(x, y, deg=2)\n\n        # Combine signal before spectrum maximum with interpolated values\n        y_values = cast(\n            FloatArray,\n            np.concatenate(\n                [\n                    self.spectrum_dB()[:_from],\n                    poly_fit(self.frequency[_from:]),\n                ]\n            ),\n        )\n        signal_power = 10 ** (y_values / 10) * self.maximum_spectral_density**2\n        return signal_power / self.estimate_avg_noise_power(omega_power=omega_power)\n\n    def estimate_peak_to_peak(\n        self: Pulse, delay_tolerance: float | None = None\n    ) -&gt; float:\n        \"\"\"Estimates the peak-to-peak value of the pulse.\n\n        If a delay tolerance is provided, the peak-to-peak value is estimated by interpolating the pulse at the maximum and minimum values such that the minimum and maximum values of the pulse fall within the given delay tolerance. A lower tolerance will give a more accurate estimate.\n\n        Args:\n            delay_tolerance: Tolerance for peak detection. Defaults to None.\n\n        Returns:\n            float: Estimated peak-to-peak value.\n        \"\"\"\n        if delay_tolerance is None:\n            return float(np.max(self.signal) - np.min(self.signal))\n\n        if delay_tolerance &gt;= self.dt:\n            msg = \"Tolerance must be smaller than the time spacing of the pulse.\"\n            raise ValueError(msg)\n\n        max_estimate = ws_interpolate(\n            times=self.time,\n            pulse=self.signal,\n            interp_times=np.linspace(\n                self.delay_at_max - self.dt,\n                self.delay_at_max + self.dt,\n                num=1 + int(self.dt / delay_tolerance),\n                endpoint=True,\n            ),\n        )\n\n        min_estimate = ws_interpolate(\n            times=self.time,\n            pulse=self.signal,\n            interp_times=np.linspace(\n                self.delay_at_min - self.dt,\n                self.delay_at_min + self.dt,\n                num=1 + int(self.dt / delay_tolerance),\n                endpoint=True,\n            ),\n        )\n\n        return cast(float, np.max(max_estimate) - np.min(min_estimate))\n\n    def to_native_dict(self: Pulse) -&gt; dict[str, list[float] | None]:\n        \"\"\"Converts the Pulse object to a native dictionary.\n\n        Returns:\n            Native dictionary representation of the Pulse object.\n        \"\"\"\n        return {\n            \"time\": list(self.time),\n            \"signal\": list(self.signal),\n            \"signal_err\": None if self.signal_err is None else list(self.signal_err),\n        }\n\n    def _get_min_or_max_idx(self: Pulse, *, wrt_max: bool) -&gt; int:\n        return int(np.argmax(self.signal)) if wrt_max else int(np.argmin(self.signal))\n\n    def _estimate_pulse_properties(\n        self: Pulse, omega_power: int\n    ) -&gt; tuple[float, float, float]:\n        argmax = np.argmax(np.abs(self.fft))\n        freqs = self.frequency[argmax:]\n        abs_spectrum = np.abs(self.fft[argmax:])\n\n        noisefloor_idx_estimate = np.argmin(abs_spectrum * freqs**omega_power)\n        avg_noise_power = np.mean(abs_spectrum[noisefloor_idx_estimate:] ** 2)\n        noisefloor = np.sqrt(avg_noise_power)\n\n        # Search for the first index, where the spectrum is above the noise floor\n        # by flipping the spectrum to get a pseudo-increasing array, then convert back\n        # to an index in the original array\n        cutoff_idx = noisefloor_idx_estimate - np.searchsorted(\n            np.flip(abs_spectrum[: noisefloor_idx_estimate + 1]),\n            noisefloor,\n            side=\"right\",\n        )\n        bandwidth = freqs[cutoff_idx]\n        dynamic_range_dB = 20 * np.log10(self.maximum_spectral_density / noisefloor)\n        return bandwidth, dynamic_range_dB, avg_noise_power\n</code></pre>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.center_frequency","title":"<code>center_frequency: float</code>  <code>property</code>","text":"<p>The frequency of the pulse with the highest spectral desnity.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.delay_at_max","title":"<code>delay_at_max: float</code>  <code>property</code>","text":"<p>Time delay at the maximum value of the pulse.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.delay_at_min","title":"<code>delay_at_min: float</code>  <code>property</code>","text":"<p>Time delay at the minimum value of the pulse.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.df","title":"<code>df: float</code>  <code>property</code>","text":"<p>Frequency spacing.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.dt","title":"<code>dt: float</code>  <code>property</code>","text":"<p>Time spacing.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.fft","title":"<code>fft: ComplexArray</code>  <code>cached</code> <code>property</code>","text":"<p>Return the Fourier Transform of a signal.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.frequency","title":"<code>frequency: FloatArray</code>  <code>cached</code> <code>property</code>","text":"<p>Return the Fourier Transform sample frequencies.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.maximum_spectral_density","title":"<code>maximum_spectral_density: float</code>  <code>property</code>","text":"<p>The maximum spectral density of the pulse.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.sampling_freq","title":"<code>sampling_freq: float</code>  <code>property</code>","text":"<p>The sampling frequency in Hz of the scan.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.time_window","title":"<code>time_window: float</code>  <code>property</code>","text":"<p>The scan time window size in seconds.</p>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.__eq__","title":"<code>__eq__(obj)</code>","text":"<p>Check if two pulses are equal.</p> Source code in <code>src/pyglaze/datamodels/pulse.py</code> <pre><code>def __eq__(self: Pulse, obj: object) -&gt; bool:\n    \"\"\"Check if two pulses are equal.\"\"\"\n    if not isinstance(obj, Pulse):\n        return False\n\n    return bool(\n        np.array_equal(self.time, obj.time)\n        and np.array_equal(self.signal, obj.signal)\n        and np.array_equal(self.signal_err, obj.signal_err)  # type: ignore[arg-type]\n    )\n</code></pre>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.add_white_noise","title":"<code>add_white_noise(noise_std, seed=None)</code>","text":"<p>Adds Gaussian noise to each timedomain measurements with a standard deviation given by <code>noise_std</code>.</p> <p>Parameters:</p> Name Type Description Default <code>noise_std</code> <code>float</code> <p>noise standard deviation</p> required <code>seed</code> <code>int | None</code> <p>Seed for the random number generator. If none, a random seed is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>Pulse</code> <p>Pulse with noise</p> Source code in <code>src/pyglaze/datamodels/pulse.py</code> <pre><code>def add_white_noise(\n    self: Pulse, noise_std: float, seed: int | None = None\n) -&gt; Pulse:\n    \"\"\"Adds Gaussian noise to each timedomain measurements with a standard deviation given by `noise_std`.\n\n    Args:\n        noise_std: noise standard deviation\n        seed: Seed for the random number generator. If none, a random seed is used.\n\n    Returns:\n        Pulse with noise\n    \"\"\"\n    return Pulse(\n        time=self.time,\n        signal=self.signal\n        + np.random.default_rng(seed).normal(\n            loc=0, scale=noise_std, size=len(self)\n        ),\n        signal_err=np.ones(len(self)) * noise_std,\n    )\n</code></pre>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.align","title":"<code>align(scans, *, wrt_max=True, translate_to_zero=True)</code>  <code>classmethod</code>","text":"<p>Aligns a list of scan with respect to their individual maxima or minima.</p> <p>Parameters:</p> Name Type Description Default <code>scans</code> <code>list[Pulse]</code> <p>List of scans</p> required <code>wrt_max</code> <code>bool</code> <p>Whether to align with respect to maximum. Defaults to True.</p> <code>True</code> <code>translate_to_zero</code> <code>bool</code> <p>Whether to translate all scans to t[0] = 0. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[Pulse]</code> <p>list[Pulse]: Aligned scans.</p> Source code in <code>src/pyglaze/datamodels/pulse.py</code> <pre><code>@classmethod\ndef align(\n    cls: type[Pulse],\n    scans: list[Pulse],\n    *,\n    wrt_max: bool = True,\n    translate_to_zero: bool = True,\n) -&gt; list[Pulse]:\n    \"\"\"Aligns a list of scan with respect to their individual maxima or minima.\n\n    Args:\n        scans: List of scans\n        wrt_max: Whether to align with respect to maximum. Defaults to True.\n        translate_to_zero: Whether to translate all scans to t[0] = 0. Defaults to True.\n\n    Returns:\n        list[Pulse]: Aligned scans.\n    \"\"\"\n    extrema = [scan._get_min_or_max_idx(wrt_max=wrt_max) for scan in scans]  # noqa: SLF001\n    n_before = min(extrema)\n    n_after = min(len(scan) - index - 1 for scan, index in zip(scans, extrema))\n    roughly_aligned = [\n        cls._from_slice(scan, slice(index - n_before, index + n_after))\n        for index, scan in zip(extrema, scans)\n    ]\n\n    if translate_to_zero:\n        for scan in roughly_aligned:\n            scan.time = scan.time - scan.time[0]\n\n    ref = roughly_aligned[len(roughly_aligned) // 2]\n    extremum = extrema[len(roughly_aligned) // 2]\n    return _match_templates(extremum, ref, roughly_aligned)\n</code></pre>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.average","title":"<code>average(scans)</code>  <code>classmethod</code>","text":"<p>Creates a Pulse object containing the average scan from a list of scans along with uncertainties. Errors are calculated as the standard errors on the means.</p> <p>Parameters:</p> Name Type Description Default <code>scans</code> <code>list[Pulse]</code> <p>List of scans to calculate average from</p> required Source code in <code>src/pyglaze/datamodels/pulse.py</code> <pre><code>@classmethod\ndef average(cls: type[Pulse], scans: list[Pulse]) -&gt; Pulse:\n    \"\"\"Creates a Pulse object containing the average scan from a list of scans along with uncertainties. Errors are calculated as the standard errors on the means.\n\n    Args:\n        scans: List of scans to calculate average from\n\n    \"\"\"\n    if len(scans) == 1:\n        return scans[0]\n    signals = np.array([scan.signal for scan in scans])\n    mean_signal = np.mean(signals, axis=0)\n\n    root_n_scans = np.sqrt(len(scans))\n    std_signal = np.std(signals, axis=0, ddof=1) / root_n_scans\n    return Pulse(scans[0].time, mean_signal, signal_err=std_signal)\n</code></pre>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.cut","title":"<code>cut(from_time, to_time)</code>","text":"<p>Create a Pulse object by cutting out a specific section of the scan.</p> <p>Parameters:</p> Name Type Description Default <code>from_time</code> <code>float</code> <p>Time in seconds where cut should be made from</p> required <code>to_time</code> <code>float</code> <p>Time in seconds where cut should be made to</p> required Source code in <code>src/pyglaze/datamodels/pulse.py</code> <pre><code>def cut(self: Pulse, from_time: float, to_time: float) -&gt; Pulse:\n    \"\"\"Create a Pulse object by cutting out a specific section of the scan.\n\n    Args:\n        from_time: Time in seconds where cut should be made from\n        to_time: Time in seconds where cut should be made to\n    \"\"\"\n    from_idx = int(np.searchsorted(self.time, from_time))\n    to_idx = int(np.searchsorted(self.time, to_time, side=\"right\"))\n    return Pulse(\n        self.time[from_idx:to_idx],\n        self.signal[from_idx:to_idx],\n        None if self.signal_err is None else self.signal_err[from_idx:to_idx],\n    )\n</code></pre>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.derivative","title":"<code>derivative()</code>","text":"<p>Calculates the derivative of the pulse.</p> <p>Returns:</p> Name Type Description <code>Pulse</code> <code>Pulse</code> <p>New Pulse object containing the derivative</p> Source code in <code>src/pyglaze/datamodels/pulse.py</code> <pre><code>def derivative(self: Pulse) -&gt; Pulse:\n    \"\"\"Calculates the derivative of the pulse.\n\n    Returns:\n        Pulse: New Pulse object containing the derivative\n    \"\"\"\n    return Pulse(time=self.time, signal=np.gradient(self.signal))\n</code></pre>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.downsample","title":"<code>downsample(max_frequency)</code>","text":"<p>Downsamples the pulse by inverse Fourier transforming the spectrum cut at the supplied <code>max_frequency</code>.</p> <p>Parameters:</p> Name Type Description Default <code>max_frequency</code> <code>float</code> <p>Maximum frequency bin after downsampling</p> required <p>Returns:</p> Name Type Description <code>Pulse</code> <code>Pulse</code> <p>Downsampled pulse</p> Source code in <code>src/pyglaze/datamodels/pulse.py</code> <pre><code>def downsample(self: Pulse, max_frequency: float) -&gt; Pulse:\n    \"\"\"Downsamples the pulse by inverse Fourier transforming the spectrum cut at the supplied `max_frequency`.\n\n    Args:\n        max_frequency: Maximum frequency bin after downsampling\n\n    Returns:\n        Pulse: Downsampled pulse\n    \"\"\"\n    idx = np.searchsorted(self.frequency, max_frequency)\n    new_fft = self.fft[:idx]\n    new_dt = 1 / (2 * self.frequency[:idx][-1])\n    new_times = np.arange(2 * (len(new_fft) - 1)) * new_dt + self.time[0]\n    return Pulse.from_fft(time=new_times, fft=new_fft)\n</code></pre>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.estimate_SNR","title":"<code>estimate_SNR(omega_power=3)</code>","text":"<p>Estimates the signal-to-noise ratio.</p> <p>Estimates the SNR, assuming white noise. Uses the approach described in Algorithm for Determination of Cutoff Frequency of Noise Floor Level for Terahertz Time-Domain Signals to estimate the noise power. The signal power is then extrapolated above the bandwidth by fitting a second order polynomial to the spectrum above the noisefloor.</p> <p>Parameters:</p> Name Type Description Default <code>omega_power</code> <code>int</code> <p>power to raise omega to before estimating the signal-to-noise ratio. Defaults to 3</p> <code>3</code> <p>Returns:</p> Name Type Description <code>float</code> <code>FloatArray</code> <p>Estimated signal-to-noise ratio.</p> Source code in <code>src/pyglaze/datamodels/pulse.py</code> <pre><code>def estimate_SNR(self: Pulse, omega_power: int = 3) -&gt; FloatArray:\n    \"\"\"Estimates the signal-to-noise ratio.\n\n    Estimates the SNR, assuming white noise. Uses the approach described in [Algorithm for Determination of Cutoff Frequency of Noise Floor Level for Terahertz Time-Domain Signals](https://doi.org/10.1007/s10762-022-00886-y) to estimate the noise power. The signal power is then extrapolated above the bandwidth by fitting a second order polynomial to the spectrum above the noisefloor.\n\n    Args:\n        omega_power: power to raise omega to before estimating the signal-to-noise ratio. Defaults to 3\n\n    Returns:\n        float: Estimated signal-to-noise ratio.\n    \"\"\"\n    # Get spectrum between maximum and noisefloor\n    _from = np.argmax(self.spectrum_dB())\n    _to = np.searchsorted(\n        self.frequency, self.estimate_bandwidth(omega_power=omega_power)\n    )\n    x = self.frequency[_from:_to]\n    y = self.spectrum_dB()[_from:_to]\n\n    # Fit a second order polynomial to the spectrum above the noisefloor\n    poly_fit = np.polynomial.Polynomial.fit(x, y, deg=2)\n\n    # Combine signal before spectrum maximum with interpolated values\n    y_values = cast(\n        FloatArray,\n        np.concatenate(\n            [\n                self.spectrum_dB()[:_from],\n                poly_fit(self.frequency[_from:]),\n            ]\n        ),\n    )\n    signal_power = 10 ** (y_values / 10) * self.maximum_spectral_density**2\n    return signal_power / self.estimate_avg_noise_power(omega_power=omega_power)\n</code></pre>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.estimate_avg_noise_power","title":"<code>estimate_avg_noise_power(omega_power=3)</code>","text":"<p>Estimates the noise power.</p> <p>Noise power is defined as the mean of the absolute square of the noise floor. Uses the approach described in Algorithm for Determination of Cutoff Frequency of Noise Floor Level for Terahertz Time-Domain Signals.</p> <p>Parameters:</p> Name Type Description Default <code>omega_power</code> <code>int</code> <p>power to raise omega to before estimating the noisepower. Defaults to 3</p> <code>3</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Estimated noise power.</p> Source code in <code>src/pyglaze/datamodels/pulse.py</code> <pre><code>def estimate_avg_noise_power(self: Pulse, omega_power: int = 3) -&gt; float:\n    \"\"\"Estimates the noise power.\n\n    Noise power is defined as the mean of the absolute square of the noise floor.\n    Uses the approach described in [Algorithm for Determination of Cutoff Frequency of Noise Floor Level for Terahertz Time-Domain Signals](https://doi.org/10.1007/s10762-022-00886-y).\n\n    Args:\n        omega_power: power to raise omega to before estimating the noisepower. Defaults to 3\n\n    Returns:\n        float: Estimated noise power.\n    \"\"\"\n    return self._estimate_pulse_properties(omega_power)[2]\n</code></pre>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.estimate_bandwidth","title":"<code>estimate_bandwidth(omega_power=3)</code>","text":"<p>Estimates the bandwidth of the pulse.</p> <p>Uses the approach described in Algorithm for Determination of Cutoff Frequency of Noise Floor Level for Terahertz Time-Domain Signals.</p> <p>Parameters:</p> Name Type Description Default <code>omega_power</code> <code>int</code> <p>power to raise omega to before estimating the bandwidth. Defaults to 3</p> <code>3</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Estimated bandwidth in Hz</p> Source code in <code>src/pyglaze/datamodels/pulse.py</code> <pre><code>def estimate_bandwidth(self: Pulse, omega_power: int = 3) -&gt; float:\n    \"\"\"Estimates the bandwidth of the pulse.\n\n    Uses the approach described in [Algorithm for Determination of Cutoff Frequency of Noise Floor Level for Terahertz Time-Domain Signals](https://doi.org/10.1007/s10762-022-00886-y).\n\n    Args:\n        omega_power: power to raise omega to before estimating the bandwidth. Defaults to 3\n\n    Returns:\n        float: Estimated bandwidth in Hz\n    \"\"\"\n    return self._estimate_pulse_properties(omega_power)[0]\n</code></pre>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.estimate_dynamic_range","title":"<code>estimate_dynamic_range(omega_power=3)</code>","text":"<p>Estimates the dynamic range of the pulse.</p> <p>Uses the approach described in Algorithm for Determination of Cutoff Frequency of Noise Floor Level for Terahertz Time-Domain Signals.</p> <p>Parameters:</p> Name Type Description Default <code>omega_power</code> <code>int</code> <p>power to raise omega to before estimating the dynamic range. Defaults to 3</p> <code>3</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Estimated dynamic range in dB</p> Source code in <code>src/pyglaze/datamodels/pulse.py</code> <pre><code>def estimate_dynamic_range(self: Pulse, omega_power: int = 3) -&gt; float:\n    \"\"\"Estimates the dynamic range of the pulse.\n\n    Uses the approach described in [Algorithm for Determination of Cutoff Frequency of Noise Floor Level for Terahertz Time-Domain Signals](https://doi.org/10.1007/s10762-022-00886-y).\n\n    Args:\n        omega_power: power to raise omega to before estimating the dynamic range. Defaults to 3\n\n    Returns:\n        float: Estimated dynamic range in dB\n    \"\"\"\n    return self._estimate_pulse_properties(omega_power)[1]\n</code></pre>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.estimate_peak_to_peak","title":"<code>estimate_peak_to_peak(delay_tolerance=None)</code>","text":"<p>Estimates the peak-to-peak value of the pulse.</p> <p>If a delay tolerance is provided, the peak-to-peak value is estimated by interpolating the pulse at the maximum and minimum values such that the minimum and maximum values of the pulse fall within the given delay tolerance. A lower tolerance will give a more accurate estimate.</p> <p>Parameters:</p> Name Type Description Default <code>delay_tolerance</code> <code>float | None</code> <p>Tolerance for peak detection. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Estimated peak-to-peak value.</p> Source code in <code>src/pyglaze/datamodels/pulse.py</code> <pre><code>def estimate_peak_to_peak(\n    self: Pulse, delay_tolerance: float | None = None\n) -&gt; float:\n    \"\"\"Estimates the peak-to-peak value of the pulse.\n\n    If a delay tolerance is provided, the peak-to-peak value is estimated by interpolating the pulse at the maximum and minimum values such that the minimum and maximum values of the pulse fall within the given delay tolerance. A lower tolerance will give a more accurate estimate.\n\n    Args:\n        delay_tolerance: Tolerance for peak detection. Defaults to None.\n\n    Returns:\n        float: Estimated peak-to-peak value.\n    \"\"\"\n    if delay_tolerance is None:\n        return float(np.max(self.signal) - np.min(self.signal))\n\n    if delay_tolerance &gt;= self.dt:\n        msg = \"Tolerance must be smaller than the time spacing of the pulse.\"\n        raise ValueError(msg)\n\n    max_estimate = ws_interpolate(\n        times=self.time,\n        pulse=self.signal,\n        interp_times=np.linspace(\n            self.delay_at_max - self.dt,\n            self.delay_at_max + self.dt,\n            num=1 + int(self.dt / delay_tolerance),\n            endpoint=True,\n        ),\n    )\n\n    min_estimate = ws_interpolate(\n        times=self.time,\n        pulse=self.signal,\n        interp_times=np.linspace(\n            self.delay_at_min - self.dt,\n            self.delay_at_min + self.dt,\n            num=1 + int(self.dt / delay_tolerance),\n            endpoint=True,\n        ),\n    )\n\n    return cast(float, np.max(max_estimate) - np.min(min_estimate))\n</code></pre>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.filter","title":"<code>filter(filtertype, cutoff, order)</code>","text":"<p>Applies a highpass filter to the signal.</p> <p>Parameters:</p> Name Type Description Default <code>filtertype</code> <code>Literal['highpass', 'lowpass']</code> <p>Type of filter</p> required <code>cutoff</code> <code>float</code> <p>Frequency, where the filter response has dropped 3 dB</p> required <code>order</code> <code>int</code> <p>Order of the highpass filter</p> required <p>Returns:</p> Type Description <code>Pulse</code> <p>Highpassed pulse</p> Source code in <code>src/pyglaze/datamodels/pulse.py</code> <pre><code>def filter(\n    self: Pulse,\n    filtertype: Literal[\"highpass\", \"lowpass\"],\n    cutoff: float,\n    order: int,\n) -&gt; Pulse:\n    \"\"\"Applies a highpass filter to the signal.\n\n    Args:\n        filtertype: Type of filter\n        cutoff: Frequency, where the filter response has dropped 3 dB\n        order: Order of the highpass filter\n\n    Returns:\n        Highpassed pulse\n    \"\"\"\n    sos = signal.butter(\n        N=order, Wn=cutoff, btype=filtertype, fs=self.sampling_freq, output=\"sos\"\n    )\n    return Pulse(self.time, np.asarray(signal.sosfilt(sos, self.signal)))\n</code></pre>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.from_dict","title":"<code>from_dict(d)</code>  <code>classmethod</code>","text":"<p>Create a Pulse object from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict[str, FloatArray | list[float] | None]</code> <p>A dictionary containing the keys 'time', 'signal' and potentially 'signal_err'.</p> required Source code in <code>src/pyglaze/datamodels/pulse.py</code> <pre><code>@classmethod\ndef from_dict(\n    cls: type[Pulse], d: dict[str, FloatArray | list[float] | None]\n) -&gt; Pulse:\n    \"\"\"Create a Pulse object from a dictionary.\n\n    Args:\n        d: A dictionary containing the keys 'time', 'signal' and potentially 'signal_err'.\n    \"\"\"\n    err = (\n        np.array(d[\"signal_err\"]) if type(d.get(\"signal_err\")) is not None else None\n    )\n    return Pulse(\n        time=np.array(d[\"time\"]), signal=np.array(d[\"signal\"]), signal_err=err\n    )\n</code></pre>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.from_fft","title":"<code>from_fft(time, fft)</code>  <code>classmethod</code>","text":"<p>Creates a Pulse object from an array of times and a Fourier spectrum.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>FloatArray</code> <p>Time series of pulse related to the Fourier spectrum</p> required <code>fft</code> <code>ComplexArray</code> <p>Fourier spectrum of pulse</p> required Source code in <code>src/pyglaze/datamodels/pulse.py</code> <pre><code>@classmethod\ndef from_fft(cls: type[Pulse], time: FloatArray, fft: ComplexArray) -&gt; Pulse:\n    \"\"\"Creates a Pulse object from an array of times and a Fourier spectrum.\n\n    Args:\n        time: Time series of pulse related to the Fourier spectrum\n        fft: Fourier spectrum of pulse\n\n    \"\"\"\n    sig = np.fft.irfft(fft, norm=\"forward\", n=len(time), axis=0)\n    return cls(time, sig)\n</code></pre>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.spectrum_dB","title":"<code>spectrum_dB(reference=None, offset_ratio=None)</code>","text":"<p>Calculates the spectral density in decibel.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>float | None</code> <p>Reference spectral amplitude. If none, the maximum of the FFT is used.</p> <code>None</code> <code>offset_ratio</code> <code>float | None</code> <p>Offset in decibel relative to the maximum of the FFT to avoid taking the logarithm of 0. If none, no offset is applied.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FloatArray</code> <code>FloatArray</code> <p>Spectral density in decibel</p> Source code in <code>src/pyglaze/datamodels/pulse.py</code> <pre><code>def spectrum_dB(\n    self: Pulse, reference: float | None = None, offset_ratio: float | None = None\n) -&gt; FloatArray:\n    \"\"\"Calculates the spectral density in decibel.\n\n    Args:\n        reference: Reference spectral amplitude. If none, the maximum of the FFT is used.\n        offset_ratio: Offset in decibel relative to the maximum of the FFT to avoid taking the logarithm of 0. If none, no offset is applied.\n\n    Returns:\n        FloatArray: Spectral density in decibel\n    \"\"\"\n    abs_spectrum = np.abs(self.fft)\n    offset = 0 if offset_ratio is None else offset_ratio * np.max(abs_spectrum)\n    ref = reference or np.max(abs_spectrum)\n\n    return np.asarray(\n        20 * np.log10((abs_spectrum + offset) / ref), dtype=np.float64\n    )\n</code></pre>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.timeshift","title":"<code>timeshift(scale, offset=0)</code>","text":"<p>Rescales and offsets the time axis as.</p> <p>new_times = scale*(t + offset)</p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>float</code> <p>Rescaling factor</p> required <code>offset</code> <code>float</code> <p>Offset. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>Pulse</code> <p>Timeshifted pulse</p> Source code in <code>src/pyglaze/datamodels/pulse.py</code> <pre><code>def timeshift(self: Pulse, scale: float, offset: float = 0) -&gt; Pulse:\n    \"\"\"Rescales and offsets the time axis as.\n\n    new_times = scale*(t + offset)\n\n    Args:\n        scale: Rescaling factor\n        offset: Offset. Defaults to 0.\n\n    Returns:\n        Timeshifted pulse\n    \"\"\"\n    return Pulse(\n        time=scale * (self.time + offset),\n        signal=self.signal,\n        signal_err=self.signal_err,\n    )\n</code></pre>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.to_native_dict","title":"<code>to_native_dict()</code>","text":"<p>Converts the Pulse object to a native dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, list[float] | None]</code> <p>Native dictionary representation of the Pulse object.</p> Source code in <code>src/pyglaze/datamodels/pulse.py</code> <pre><code>def to_native_dict(self: Pulse) -&gt; dict[str, list[float] | None]:\n    \"\"\"Converts the Pulse object to a native dictionary.\n\n    Returns:\n        Native dictionary representation of the Pulse object.\n    \"\"\"\n    return {\n        \"time\": list(self.time),\n        \"signal\": list(self.signal),\n        \"signal_err\": None if self.signal_err is None else list(self.signal_err),\n    }\n</code></pre>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.tukey","title":"<code>tukey(taper_length, from_time=None, to_time=None)</code>","text":"<p>Applies a Tukey window and returns a new Pulse object - see https://en.wikipedia.org/wiki/Window_function.</p> <p>Parameters:</p> Name Type Description Default <code>taper_length</code> <code>float</code> <p>Length in seconds of the cosine tapering length, i.e. half a cosine cycle</p> required <code>from_time</code> <code>float | None</code> <p>Left edge in seconds at which the window becomes 0</p> <code>None</code> <code>to_time</code> <code>float | None</code> <p>Right edge in seconds at which the window becomes 0</p> <code>None</code> Source code in <code>src/pyglaze/datamodels/pulse.py</code> <pre><code>def tukey(\n    self: Pulse,\n    taper_length: float,\n    from_time: float | None = None,\n    to_time: float | None = None,\n) -&gt; Pulse:\n    \"\"\"Applies a Tukey window and returns a new Pulse object - see https://en.wikipedia.org/wiki/Window_function.\n\n    Args:\n        taper_length: Length in seconds of the cosine tapering length, i.e. half a cosine cycle\n        from_time: Left edge in seconds at which the window becomes 0\n        to_time: Right edge in seconds at which the window becomes 0\n    \"\"\"\n    N = len(self)\n    _to_time = to_time or self.time[-1]\n    _from_time = from_time or self.time[0]\n    _tukey_window_length = _to_time - _from_time\n\n    # NOTE: See https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.windows.tukey.html#scipy.signal.windows.tukey\n    M = int(N * _tukey_window_length / self.time_window)\n    if M &gt; N:\n        msg = \"Number of points in Tukey window cannot exceed number of points in scan\"\n        raise ValueError(msg)\n    alpha = 2 * taper_length / _tukey_window_length\n    _tukey_window = signal.windows.tukey(M=M, alpha=alpha)\n\n    window = np.zeros(N)\n    from_time_idx = np.searchsorted(self.time, _from_time)\n    window[from_time_idx : M + from_time_idx] = _tukey_window\n\n    return Pulse(self.time, self.signal * window)\n</code></pre>"},{"location":"API%20Reference/datamodels/Pulse/#pyglaze.datamodels.Pulse.zeropadded","title":"<code>zeropadded(n_zeros)</code>","text":"<p>Returns a new, zero-padded pulse.</p> <p>Parameters:</p> Name Type Description Default <code>n_zeros</code> <code>int</code> <p>number of zeros to add</p> required <p>Returns:</p> Type Description <code>Pulse</code> <p>Zero-padded pulse</p> Source code in <code>src/pyglaze/datamodels/pulse.py</code> <pre><code>def zeropadded(self: Pulse, n_zeros: int) -&gt; Pulse:\n    \"\"\"Returns a new, zero-padded pulse.\n\n    Args:\n        n_zeros: number of zeros to add\n\n    Returns:\n        Zero-padded pulse\n    \"\"\"\n    zeropadded_signal = np.concatenate((np.zeros(n_zeros), self.signal))\n    zeropadded_time = np.concatenate(\n        (self.time[0] + np.arange(n_zeros, 0, -1) * -self.dt, self.time)\n    )\n    return Pulse(time=zeropadded_time, signal=zeropadded_signal)\n</code></pre>"},{"location":"API%20Reference/datamodels/Pulse/#notes","title":"Notes","text":"<p>The lock-in amp outputs \\(\\left( r, \\theta \\right)\\) values. To get useful readings, one must convert these readings by</p> \\[ r \\operatorname{sgn} (\\theta - 180). \\] <p>\\(\\operatorname{sgn}\\), the so-called signum function outputs the signs of a vector in a piecewise fashion, implemented in NumPy using</p> \\[ \\operatorname{sgn} = \\frac{x}{\\sqrt{x^2}}. \\] <p>This is handled by the <code>ScanData</code> class, and is done transparently when using <code>pyglaze.scanning.scanner.Scanner</code>. If you have a previous reading that has been converted, <code>ScanData</code> allows you to create an object from this data in dictionary form; see examples below.</p>"},{"location":"API%20Reference/datamodels/Pulse/#examples","title":"Examples","text":"From JSON file <pre><code>import json\nfrom pathlib import Path\n\nimport numpy as np\n\nfrom pyglaze.datamodels import Pulse\n\n# Generate a pulse - would typically be done with an actual THz device\nnew_pulse = Pulse(\n    time=np.linspace(0, 1, 100), signal=np.random.default_rng().normal(size=100)\n)\n\n# Save the pulse as a JSON file\nwith Path(\"my_pulse_data.json\").open(\"w\") as f:\n    json.dump(new_pulse.to_native_dict(), f)\n\n# Load the pulse from the JSON file again\nwith Path(\"my_pulse_data.json\").open() as f:\n    run_data = json.load(f)\n\npulse = Pulse.from_dict(d=run_data)\n</code></pre>"},{"location":"API%20Reference/datamodels/UnprocessedWaveform/","title":"UnprocessedWaveform","text":"<p><code>pyglaze.datamodels.UnprocessedWaveform</code></p> <p>A dataclass representing an unprocessed waveform. No assumptions are made about the delay or signal.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>FloatArray</code> <p>The time values recorded by the lock-in amp during the scan.</p> required <code>signal</code> <code>FloatArray</code> <p>The signal values recorded by the lock-in amp during the scan.</p> required Source code in <code>src/pyglaze/datamodels/waveform.py</code> <pre><code>@dataclass(frozen=True)\nclass UnprocessedWaveform:\n    \"\"\"A dataclass representing an unprocessed waveform. No assumptions are made about the delay or signal.\n\n    Args:\n        time: The time values recorded by the lock-in amp during the scan.\n        signal: The signal values recorded by the lock-in amp during the scan.\n    \"\"\"\n\n    time: FloatArray\n    signal: FloatArray\n\n    @classmethod\n    def from_polar_coords(\n        cls: type[UnprocessedWaveform],\n        time: FloatArray,\n        radius: FloatArray,\n        theta: FloatArray,\n        rotation_angle: float | None = None,\n    ) -&gt; UnprocessedWaveform:\n        \"\"\"Create an UnprocessedWaveform object from raw lock-in amp output.\n\n        Args:\n            time: The time values recorded by the lock-in amp during the scan.\n            radius: The radius values recorded by the lock-in amp during the scan.\n            theta: The theta values recorded by the lock-in amp during the scan (in degrees).\n            rotation_angle: The angle to rotate lockin signal to align along x-axis. If not given, will use the angle at the maximum value of R.\n        \"\"\"\n        _rot_ang = (\n            theta[np.argmax(radius)] if rotation_angle is None else rotation_angle\n        )\n\n        # rotate such that all signal lies along X\n        new_theta = theta - _rot_ang\n        signal = radius * np.cos(new_theta * np.pi / 180.0)\n        return cls(time, signal)\n\n    @classmethod\n    def from_dict(\n        cls: type[UnprocessedWaveform], d: dict[str, FloatArray | list[float] | None]\n    ) -&gt; UnprocessedWaveform:\n        \"\"\"Create an UnprocessedWaveform object from a dictionary.\n\n        Args:\n            d: A dictionary containing the keys 'time', 'signal'.\n        \"\"\"\n        return UnprocessedWaveform(\n            time=np.array(d[\"time\"]), signal=np.array(d[\"signal\"])\n        )\n\n    def reconstruct(\n        self: UnprocessedWaveform, method: RecoMethod, times: FloatArray | None = None\n    ) -&gt; UnprocessedWaveform:\n        \"\"\"Reconstructs the waveform for a specified array of times using a specified method. If no delays are given, linearly spaced times between the maximum and the minimum of the delays will be used.\n\n        Args:\n            method: Name of reconstruction method.\n            times: Optional array of delay times.\n\n        Raises:\n            ValueError: When an unknown reconstruction method is requested\n        \"\"\"\n        if times is None:\n            times = np.linspace(\n                self.time[0], self.time[-1], len(self.time), endpoint=True\n            )\n\n        if method == \"cubic_spline\":\n            return UnprocessedWaveform(\n                times, CubicSpline(self.time, self.signal)(times)\n            )\n\n        msg = f\"Unknown reconstruction method: {method}\"\n        raise ValueError(msg)\n\n    @classmethod\n    def average(\n        cls: type[UnprocessedWaveform], waveforms: list[UnprocessedWaveform]\n    ) -&gt; UnprocessedWaveform:\n        \"\"\"Computes the average of a list of UnprocessedWaveform objects.\n\n        Args:\n            waveforms: List of waveforms\n\n        \"\"\"\n        if len(waveforms) == 1:\n            return waveforms[0]\n        signals = np.array([waveform.signal for waveform in waveforms])\n        return UnprocessedWaveform(\n            time=waveforms[0].time, signal=np.mean(signals, axis=0)\n        )\n\n    def from_triangular_waveform(\n        self: UnprocessedWaveform, ramp: Literal[\"up\", \"down\"]\n    ) -&gt; UnprocessedWaveform:\n        \"\"\"Picks out the pulse from a scan with fiberstretchers driven by a triangular waveform.\n\n        Args:\n            ramp: Whether to pick out the pulse from the upgoing or downgoing ramp of the triangle wave\n\n        Raises:\n            ValueError: If 'ramp' is neither 'up' or 'down'\n\n        Returns:\n            Raw waveform\n        \"\"\"\n        argmax = np.argmax(self.time)\n        argmin = np.argmin(self.time)\n        min_before_max = argmin &lt; argmax\n        if ramp == \"up\" and min_before_max:  # down up down\n            t = self.time[argmin : argmax + 1]\n            s = self.signal[argmin : argmax + 1]\n        elif ramp == \"up\" and not min_before_max:  # up down up\n            t = np.concatenate((self.time[argmin:], self.time[: argmax + 1]))\n            s = np.concatenate((self.signal[argmin:], self.signal[: argmax + 1]))\n        elif ramp == \"down\" and min_before_max:  # down up down\n            t = np.flip(np.concatenate((self.time[argmax:], self.time[: argmin + 1])))\n            s = np.flip(\n                np.concatenate((self.signal[argmax:], self.signal[: argmin + 1]))\n            )\n        elif ramp == \"down\" and not min_before_max:  # up down up\n            t = np.flip(self.time[argmax : argmin + 1])\n            s = np.flip(self.signal[argmax : argmin + 1])\n        else:\n            msg = \"'ramp' must be either 'up' or 'down'\"\n            raise ValueError(msg)\n\n        return UnprocessedWaveform(time=t, signal=s)\n\n    def as_pulse(self: UnprocessedWaveform) -&gt; Pulse:\n        \"\"\"Converts the current waveform to a Pulse object.\"\"\"\n        return Pulse(time=self.time, signal=self.signal)\n</code></pre>"},{"location":"API%20Reference/datamodels/UnprocessedWaveform/#pyglaze.datamodels.UnprocessedWaveform.as_pulse","title":"<code>as_pulse()</code>","text":"<p>Converts the current waveform to a Pulse object.</p> Source code in <code>src/pyglaze/datamodels/waveform.py</code> <pre><code>def as_pulse(self: UnprocessedWaveform) -&gt; Pulse:\n    \"\"\"Converts the current waveform to a Pulse object.\"\"\"\n    return Pulse(time=self.time, signal=self.signal)\n</code></pre>"},{"location":"API%20Reference/datamodels/UnprocessedWaveform/#pyglaze.datamodels.UnprocessedWaveform.average","title":"<code>average(waveforms)</code>  <code>classmethod</code>","text":"<p>Computes the average of a list of UnprocessedWaveform objects.</p> <p>Parameters:</p> Name Type Description Default <code>waveforms</code> <code>list[UnprocessedWaveform]</code> <p>List of waveforms</p> required Source code in <code>src/pyglaze/datamodels/waveform.py</code> <pre><code>@classmethod\ndef average(\n    cls: type[UnprocessedWaveform], waveforms: list[UnprocessedWaveform]\n) -&gt; UnprocessedWaveform:\n    \"\"\"Computes the average of a list of UnprocessedWaveform objects.\n\n    Args:\n        waveforms: List of waveforms\n\n    \"\"\"\n    if len(waveforms) == 1:\n        return waveforms[0]\n    signals = np.array([waveform.signal for waveform in waveforms])\n    return UnprocessedWaveform(\n        time=waveforms[0].time, signal=np.mean(signals, axis=0)\n    )\n</code></pre>"},{"location":"API%20Reference/datamodels/UnprocessedWaveform/#pyglaze.datamodels.UnprocessedWaveform.from_dict","title":"<code>from_dict(d)</code>  <code>classmethod</code>","text":"<p>Create an UnprocessedWaveform object from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict[str, FloatArray | list[float] | None]</code> <p>A dictionary containing the keys 'time', 'signal'.</p> required Source code in <code>src/pyglaze/datamodels/waveform.py</code> <pre><code>@classmethod\ndef from_dict(\n    cls: type[UnprocessedWaveform], d: dict[str, FloatArray | list[float] | None]\n) -&gt; UnprocessedWaveform:\n    \"\"\"Create an UnprocessedWaveform object from a dictionary.\n\n    Args:\n        d: A dictionary containing the keys 'time', 'signal'.\n    \"\"\"\n    return UnprocessedWaveform(\n        time=np.array(d[\"time\"]), signal=np.array(d[\"signal\"])\n    )\n</code></pre>"},{"location":"API%20Reference/datamodels/UnprocessedWaveform/#pyglaze.datamodels.UnprocessedWaveform.from_polar_coords","title":"<code>from_polar_coords(time, radius, theta, rotation_angle=None)</code>  <code>classmethod</code>","text":"<p>Create an UnprocessedWaveform object from raw lock-in amp output.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>FloatArray</code> <p>The time values recorded by the lock-in amp during the scan.</p> required <code>radius</code> <code>FloatArray</code> <p>The radius values recorded by the lock-in amp during the scan.</p> required <code>theta</code> <code>FloatArray</code> <p>The theta values recorded by the lock-in amp during the scan (in degrees).</p> required <code>rotation_angle</code> <code>float | None</code> <p>The angle to rotate lockin signal to align along x-axis. If not given, will use the angle at the maximum value of R.</p> <code>None</code> Source code in <code>src/pyglaze/datamodels/waveform.py</code> <pre><code>@classmethod\ndef from_polar_coords(\n    cls: type[UnprocessedWaveform],\n    time: FloatArray,\n    radius: FloatArray,\n    theta: FloatArray,\n    rotation_angle: float | None = None,\n) -&gt; UnprocessedWaveform:\n    \"\"\"Create an UnprocessedWaveform object from raw lock-in amp output.\n\n    Args:\n        time: The time values recorded by the lock-in amp during the scan.\n        radius: The radius values recorded by the lock-in amp during the scan.\n        theta: The theta values recorded by the lock-in amp during the scan (in degrees).\n        rotation_angle: The angle to rotate lockin signal to align along x-axis. If not given, will use the angle at the maximum value of R.\n    \"\"\"\n    _rot_ang = (\n        theta[np.argmax(radius)] if rotation_angle is None else rotation_angle\n    )\n\n    # rotate such that all signal lies along X\n    new_theta = theta - _rot_ang\n    signal = radius * np.cos(new_theta * np.pi / 180.0)\n    return cls(time, signal)\n</code></pre>"},{"location":"API%20Reference/datamodels/UnprocessedWaveform/#pyglaze.datamodels.UnprocessedWaveform.from_triangular_waveform","title":"<code>from_triangular_waveform(ramp)</code>","text":"<p>Picks out the pulse from a scan with fiberstretchers driven by a triangular waveform.</p> <p>Parameters:</p> Name Type Description Default <code>ramp</code> <code>Literal['up', 'down']</code> <p>Whether to pick out the pulse from the upgoing or downgoing ramp of the triangle wave</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If 'ramp' is neither 'up' or 'down'</p> <p>Returns:</p> Type Description <code>UnprocessedWaveform</code> <p>Raw waveform</p> Source code in <code>src/pyglaze/datamodels/waveform.py</code> <pre><code>def from_triangular_waveform(\n    self: UnprocessedWaveform, ramp: Literal[\"up\", \"down\"]\n) -&gt; UnprocessedWaveform:\n    \"\"\"Picks out the pulse from a scan with fiberstretchers driven by a triangular waveform.\n\n    Args:\n        ramp: Whether to pick out the pulse from the upgoing or downgoing ramp of the triangle wave\n\n    Raises:\n        ValueError: If 'ramp' is neither 'up' or 'down'\n\n    Returns:\n        Raw waveform\n    \"\"\"\n    argmax = np.argmax(self.time)\n    argmin = np.argmin(self.time)\n    min_before_max = argmin &lt; argmax\n    if ramp == \"up\" and min_before_max:  # down up down\n        t = self.time[argmin : argmax + 1]\n        s = self.signal[argmin : argmax + 1]\n    elif ramp == \"up\" and not min_before_max:  # up down up\n        t = np.concatenate((self.time[argmin:], self.time[: argmax + 1]))\n        s = np.concatenate((self.signal[argmin:], self.signal[: argmax + 1]))\n    elif ramp == \"down\" and min_before_max:  # down up down\n        t = np.flip(np.concatenate((self.time[argmax:], self.time[: argmin + 1])))\n        s = np.flip(\n            np.concatenate((self.signal[argmax:], self.signal[: argmin + 1]))\n        )\n    elif ramp == \"down\" and not min_before_max:  # up down up\n        t = np.flip(self.time[argmax : argmin + 1])\n        s = np.flip(self.signal[argmax : argmin + 1])\n    else:\n        msg = \"'ramp' must be either 'up' or 'down'\"\n        raise ValueError(msg)\n\n    return UnprocessedWaveform(time=t, signal=s)\n</code></pre>"},{"location":"API%20Reference/datamodels/UnprocessedWaveform/#pyglaze.datamodels.UnprocessedWaveform.reconstruct","title":"<code>reconstruct(method, times=None)</code>","text":"<p>Reconstructs the waveform for a specified array of times using a specified method. If no delays are given, linearly spaced times between the maximum and the minimum of the delays will be used.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>RecoMethod</code> <p>Name of reconstruction method.</p> required <code>times</code> <code>FloatArray | None</code> <p>Optional array of delay times.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>When an unknown reconstruction method is requested</p> Source code in <code>src/pyglaze/datamodels/waveform.py</code> <pre><code>def reconstruct(\n    self: UnprocessedWaveform, method: RecoMethod, times: FloatArray | None = None\n) -&gt; UnprocessedWaveform:\n    \"\"\"Reconstructs the waveform for a specified array of times using a specified method. If no delays are given, linearly spaced times between the maximum and the minimum of the delays will be used.\n\n    Args:\n        method: Name of reconstruction method.\n        times: Optional array of delay times.\n\n    Raises:\n        ValueError: When an unknown reconstruction method is requested\n    \"\"\"\n    if times is None:\n        times = np.linspace(\n            self.time[0], self.time[-1], len(self.time), endpoint=True\n        )\n\n    if method == \"cubic_spline\":\n        return UnprocessedWaveform(\n            times, CubicSpline(self.time, self.signal)(times)\n        )\n\n    msg = f\"Unknown reconstruction method: {method}\"\n    raise ValueError(msg)\n</code></pre>"},{"location":"API%20Reference/device/ForceDeviceConfiguration/","title":"ForceDeviceConfiguration","text":"<p><code>pyglaze.device.ForceDeviceConfiguration</code></p> <p>               Bases: <code>DeviceConfiguration</code></p> <p>Represents a configuration that can be sent to the lock-in amp for scans.</p> <p>Parameters:</p> Name Type Description Default <code>amp_port</code> <code>str</code> <p>The name of the serial port the amp is connected to.</p> required <code>sweep_length_ms</code> <code>float</code> <p>The length of the sweep in milliseconds.</p> required <code>delayunit</code> <code>str</code> <p>Name of the delay calculator.</p> required <code>scan_intervals</code> <code>list[Interval]</code> <p>The intervals to scan.</p> <code>lambda: [Interval(0.0, 1.0)]()</code> <code>integration_periods</code> <code>int</code> <p>The number of integration periods to use.</p> <code>100</code> <code>modulation_frequency</code> <code>int</code> <p>The frequency of the modulation in Hz.</p> <code>10000</code> <code>dac_lower_bound</code> <code>int</code> <p>The lower bound of the modulation voltage in bits.</p> <code>6400</code> <code>dac_upper_bound</code> <code>int</code> <p>The upper bound of the modulation voltage in bits.</p> <code>59300</code> <code>min_modulation_voltage</code> <code>float</code> <p>The minimum modulation voltage in volts.</p> <code>-1.0</code> <code>max_modulation_voltage</code> <code>float</code> <p>The maximum modulation voltage in volts.</p> <code>0.5</code> <code>modulation_waveform</code> <code>str</code> <p>The waveform to use for modulation.</p> <code>'square'</code> <code>amp_timeout_seconds</code> <code>float</code> <p>The timeout for the amp in seconds.</p> <code>0.05</code> Source code in <code>src/pyglaze/device/configuration.py</code> <pre><code>@dataclass\nclass ForceDeviceConfiguration(DeviceConfiguration):\n    \"\"\"Represents a configuration that can be sent to the lock-in amp for scans.\n\n    Args:\n        amp_port: The name of the serial port the amp is connected to.\n        sweep_length_ms: The length of the sweep in milliseconds.\n        delayunit: Name of the delay calculator.\n        scan_intervals: The intervals to scan.\n        integration_periods: The number of integration periods to use.\n        modulation_frequency: The frequency of the modulation in Hz.\n        dac_lower_bound: The lower bound of the modulation voltage in bits.\n        dac_upper_bound: The upper bound of the modulation voltage in bits.\n        min_modulation_voltage: The minimum modulation voltage in volts.\n        max_modulation_voltage: The maximum modulation voltage in volts.\n        modulation_waveform: The waveform to use for modulation.\n        amp_timeout_seconds: The timeout for the amp in seconds.\n    \"\"\"\n\n    amp_port: str\n    sweep_length_ms: float\n    delayunit: str\n    scan_intervals: list[Interval] = field(default_factory=lambda: [Interval(0.0, 1.0)])\n    integration_periods: int = 100\n    modulation_frequency: int = 10000  # Hz\n    dac_lower_bound: int = 6400\n    dac_upper_bound: int = 59300\n    min_modulation_voltage: float = -1.0  # V\n    max_modulation_voltage: float = 0.5  # V\n    modulation_waveform: str = \"square\"\n    amp_timeout_seconds: float = 0.05\n\n    amp_baudrate: ClassVar[int] = 1200000  # bit/s\n\n    @property\n    def _sweep_length_ms(self: ForceDeviceConfiguration) -&gt; float:\n        return self.sweep_length_ms\n\n    def __post_init__(self: ForceDeviceConfiguration) -&gt; None:  # noqa: D105\n        validate_delayunit(self.delayunit)\n\n    def save(self: ForceDeviceConfiguration, path: Path) -&gt; str:\n        \"\"\"Save a DeviceConfiguration to a file.\n\n        Args:\n            path: The path to save the configuration to.\n\n        Returns:\n            str: Final path component of the saved file, without the extension.\n\n        \"\"\"\n        with path.open(\"w\") as f:\n            json.dump(asdict(self), f, indent=4, sort_keys=True)\n\n        return path.stem\n\n    @classmethod\n    def from_dict(\n        cls: type[ForceDeviceConfiguration], amp_config: dict\n    ) -&gt; ForceDeviceConfiguration:\n        \"\"\"Create a DeviceConfiguration from a dict.\n\n        Args:\n            amp_config: An amp configuration in dict form.\n\n        Raises:\n            ValueError: If the dictionary is empty.\n\n        Returns:\n            DeviceConfiguration: A DeviceConfiguration object.\n        \"\"\"\n        return _config_w_intervals_from_dict(cls, amp_config)\n\n    @classmethod\n    def load(\n        cls: type[ForceDeviceConfiguration], file_path: Path\n    ) -&gt; ForceDeviceConfiguration:\n        \"\"\"Load a DeviceConfiguration from a file.\n\n        Args:\n            file_path: The path to the file to load.\n\n        Returns:\n            DeviceConfiguration: A DeviceConfiguration object.\n        \"\"\"\n        with file_path.open() as f:\n            configuration_dict = json.load(f)\n        return cls.from_dict(configuration_dict)\n</code></pre> <p><code>pyglaze.device.LeDeviceConfiguration</code></p> <p>               Bases: <code>DeviceConfiguration</code></p> <p>Represents a configuration that can be sent to a Le-type lock-in amp for scans.</p> <p>Parameters:</p> Name Type Description Default <code>amp_port</code> <code>str</code> <p>The name of the serial port the amp is connected to.</p> required <code>delayunit</code> <code>str</code> <p>Name of the delay calculator.</p> required <code>use_ema</code> <code>bool</code> <p>Whether to use en exponentially moving average filter during lockin detection.</p> <code>True</code> <code>n_points</code> <code>int</code> <p>The number of points to scan.</p> <code>1000</code> <code>scan_intervals</code> <code>list[Interval]</code> <p>The intervals to scan.</p> <code>lambda: [Interval(0.0, 1.0)]()</code> <code>integration_periods</code> <code>int</code> <p>The number of integration periods per datapoint to use.</p> <code>10</code> <code>amp_timeout_seconds</code> <code>float</code> <p>The timeout for the connection to the amp in seconds.</p> <code>0.2</code> Source code in <code>src/pyglaze/device/configuration.py</code> <pre><code>@dataclass\nclass LeDeviceConfiguration(DeviceConfiguration):\n    \"\"\"Represents a configuration that can be sent to a Le-type lock-in amp for scans.\n\n    Args:\n        amp_port: The name of the serial port the amp is connected to.\n        delayunit: Name of the delay calculator.\n        use_ema: Whether to use en exponentially moving average filter during lockin detection.\n        n_points: The number of points to scan.\n        scan_intervals: The intervals to scan.\n        integration_periods: The number of integration periods per datapoint to use.\n        amp_timeout_seconds: The timeout for the connection to the amp in seconds.\n    \"\"\"\n\n    amp_port: str\n    delayunit: str\n    use_ema: bool = True\n    n_points: int = 1000\n    scan_intervals: list[Interval] = field(default_factory=lambda: [Interval(0.0, 1.0)])\n    integration_periods: int = 10\n    amp_timeout_seconds: float = 0.2\n\n    modulation_frequency: ClassVar[int] = 10000  # Hz\n    fs_dac_lower_bound: ClassVar[int] = 300\n    fs_dac_upper_bound: ClassVar[int] = 3700\n    amp_baudrate: ClassVar[int] = 1000000  # bit/s\n\n    def __post_init__(self: LeDeviceConfiguration) -&gt; None:  # noqa: D105\n        validate_delayunit(self.delayunit)\n\n    @property\n    def _sweep_length_ms(self: LeDeviceConfiguration) -&gt; float:\n        return self.n_points * self._time_constant_ms\n\n    @property\n    def _time_constant_ms(self: LeDeviceConfiguration) -&gt; float:\n        return 1e3 * self.integration_periods / self.modulation_frequency\n\n    def save(self: LeDeviceConfiguration, path: Path) -&gt; str:\n        \"\"\"Save a LeDeviceConfiguration to a file.\n\n        Args:\n            path: The path to save the configuration to.\n\n        Returns:\n            str: Final path component of the saved file, without the extension.\n\n        \"\"\"\n        with path.open(\"w\") as f:\n            json.dump(asdict(self), f, indent=4, sort_keys=True)\n\n        return path.stem\n\n    @classmethod\n    def from_dict(\n        cls: type[LeDeviceConfiguration], amp_config: dict\n    ) -&gt; LeDeviceConfiguration:\n        \"\"\"Create a LeDeviceConfiguration from a dict.\n\n        Args:\n            amp_config: An amp configuration in dict form.\n\n        Raises:\n            ValueError: If the dictionary is empty.\n\n        Returns:\n            DeviceConfiguration: A DeviceConfiguration object.\n        \"\"\"\n        return _config_w_intervals_from_dict(cls, amp_config)\n\n    @classmethod\n    def load(\n        cls: type[LeDeviceConfiguration], file_path: Path\n    ) -&gt; LeDeviceConfiguration:\n        \"\"\"Load a LeDeviceConfiguration from a file.\n\n        Args:\n            file_path: The path to the file to load.\n\n        Returns:\n            DeviceConfiguration: A DeviceConfiguration object.\n        \"\"\"\n        with file_path.open() as f:\n            configuration_dict = json.load(f)\n        return cls.from_dict(configuration_dict)\n</code></pre>"},{"location":"API%20Reference/device/ForceDeviceConfiguration/#pyglaze.device.ForceDeviceConfiguration.from_dict","title":"<code>from_dict(amp_config)</code>  <code>classmethod</code>","text":"<p>Create a DeviceConfiguration from a dict.</p> <p>Parameters:</p> Name Type Description Default <code>amp_config</code> <code>dict</code> <p>An amp configuration in dict form.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the dictionary is empty.</p> <p>Returns:</p> Name Type Description <code>DeviceConfiguration</code> <code>ForceDeviceConfiguration</code> <p>A DeviceConfiguration object.</p> Source code in <code>src/pyglaze/device/configuration.py</code> <pre><code>@classmethod\ndef from_dict(\n    cls: type[ForceDeviceConfiguration], amp_config: dict\n) -&gt; ForceDeviceConfiguration:\n    \"\"\"Create a DeviceConfiguration from a dict.\n\n    Args:\n        amp_config: An amp configuration in dict form.\n\n    Raises:\n        ValueError: If the dictionary is empty.\n\n    Returns:\n        DeviceConfiguration: A DeviceConfiguration object.\n    \"\"\"\n    return _config_w_intervals_from_dict(cls, amp_config)\n</code></pre>"},{"location":"API%20Reference/device/ForceDeviceConfiguration/#pyglaze.device.ForceDeviceConfiguration.load","title":"<code>load(file_path)</code>  <code>classmethod</code>","text":"<p>Load a DeviceConfiguration from a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>The path to the file to load.</p> required <p>Returns:</p> Name Type Description <code>DeviceConfiguration</code> <code>ForceDeviceConfiguration</code> <p>A DeviceConfiguration object.</p> Source code in <code>src/pyglaze/device/configuration.py</code> <pre><code>@classmethod\ndef load(\n    cls: type[ForceDeviceConfiguration], file_path: Path\n) -&gt; ForceDeviceConfiguration:\n    \"\"\"Load a DeviceConfiguration from a file.\n\n    Args:\n        file_path: The path to the file to load.\n\n    Returns:\n        DeviceConfiguration: A DeviceConfiguration object.\n    \"\"\"\n    with file_path.open() as f:\n        configuration_dict = json.load(f)\n    return cls.from_dict(configuration_dict)\n</code></pre>"},{"location":"API%20Reference/device/ForceDeviceConfiguration/#pyglaze.device.ForceDeviceConfiguration.save","title":"<code>save(path)</code>","text":"<p>Save a DeviceConfiguration to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to save the configuration to.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Final path component of the saved file, without the extension.</p> Source code in <code>src/pyglaze/device/configuration.py</code> <pre><code>def save(self: ForceDeviceConfiguration, path: Path) -&gt; str:\n    \"\"\"Save a DeviceConfiguration to a file.\n\n    Args:\n        path: The path to save the configuration to.\n\n    Returns:\n        str: Final path component of the saved file, without the extension.\n\n    \"\"\"\n    with path.open(\"w\") as f:\n        json.dump(asdict(self), f, indent=4, sort_keys=True)\n\n    return path.stem\n</code></pre>"},{"location":"API%20Reference/device/ForceDeviceConfiguration/#pyglaze.device.LeDeviceConfiguration.from_dict","title":"<code>from_dict(amp_config)</code>  <code>classmethod</code>","text":"<p>Create a LeDeviceConfiguration from a dict.</p> <p>Parameters:</p> Name Type Description Default <code>amp_config</code> <code>dict</code> <p>An amp configuration in dict form.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the dictionary is empty.</p> <p>Returns:</p> Name Type Description <code>DeviceConfiguration</code> <code>LeDeviceConfiguration</code> <p>A DeviceConfiguration object.</p> Source code in <code>src/pyglaze/device/configuration.py</code> <pre><code>@classmethod\ndef from_dict(\n    cls: type[LeDeviceConfiguration], amp_config: dict\n) -&gt; LeDeviceConfiguration:\n    \"\"\"Create a LeDeviceConfiguration from a dict.\n\n    Args:\n        amp_config: An amp configuration in dict form.\n\n    Raises:\n        ValueError: If the dictionary is empty.\n\n    Returns:\n        DeviceConfiguration: A DeviceConfiguration object.\n    \"\"\"\n    return _config_w_intervals_from_dict(cls, amp_config)\n</code></pre>"},{"location":"API%20Reference/device/ForceDeviceConfiguration/#pyglaze.device.LeDeviceConfiguration.load","title":"<code>load(file_path)</code>  <code>classmethod</code>","text":"<p>Load a LeDeviceConfiguration from a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>The path to the file to load.</p> required <p>Returns:</p> Name Type Description <code>DeviceConfiguration</code> <code>LeDeviceConfiguration</code> <p>A DeviceConfiguration object.</p> Source code in <code>src/pyglaze/device/configuration.py</code> <pre><code>@classmethod\ndef load(\n    cls: type[LeDeviceConfiguration], file_path: Path\n) -&gt; LeDeviceConfiguration:\n    \"\"\"Load a LeDeviceConfiguration from a file.\n\n    Args:\n        file_path: The path to the file to load.\n\n    Returns:\n        DeviceConfiguration: A DeviceConfiguration object.\n    \"\"\"\n    with file_path.open() as f:\n        configuration_dict = json.load(f)\n    return cls.from_dict(configuration_dict)\n</code></pre>"},{"location":"API%20Reference/device/ForceDeviceConfiguration/#pyglaze.device.LeDeviceConfiguration.save","title":"<code>save(path)</code>","text":"<p>Save a LeDeviceConfiguration to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to save the configuration to.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Final path component of the saved file, without the extension.</p> Source code in <code>src/pyglaze/device/configuration.py</code> <pre><code>def save(self: LeDeviceConfiguration, path: Path) -&gt; str:\n    \"\"\"Save a LeDeviceConfiguration to a file.\n\n    Args:\n        path: The path to save the configuration to.\n\n    Returns:\n        str: Final path component of the saved file, without the extension.\n\n    \"\"\"\n    with path.open(\"w\") as f:\n        json.dump(asdict(self), f, indent=4, sort_keys=True)\n\n    return path.stem\n</code></pre>"},{"location":"API%20Reference/device/ForceDeviceConfiguration/#examples","title":"Examples","text":""},{"location":"API%20Reference/device/ForceDeviceConfiguration/#make-a-device-configuration","title":"Make a device configuration","text":"<p>Depending on which device is used, a matching device configuration must be used.</p> ForceDeviceConfiguration <pre><code>from pyglaze.device import ForceDeviceConfiguration\n\nconfig = ForceDeviceConfiguration(\n    amp_port=\"mock_device\", sweep_length_ms=6000, delayunit=\"mock_delay\"\n)\n</code></pre> LeDeviceConfiguration <pre><code>from pyglaze.device import LeDeviceConfiguration\n\nconfig = LeDeviceConfiguration(\n    amp_port=\"mock_device\", delayunit=\"mock_delay\", use_ema=True\n)\n</code></pre> <p>Be sure to use the correct port and delayunit! The <code>mock_device</code> and <code>mock_delay</code> are only for testing purposes</p>"},{"location":"API%20Reference/device/LeDeviceConfiguration/","title":"LeDeviceConfiguration","text":"<p><code>pyglaze.device.LeDeviceConfiguration</code></p> <p>               Bases: <code>DeviceConfiguration</code></p> <p>Represents a configuration that can be sent to a Le-type lock-in amp for scans.</p> <p>Parameters:</p> Name Type Description Default <code>amp_port</code> <code>str</code> <p>The name of the serial port the amp is connected to.</p> required <code>delayunit</code> <code>str</code> <p>Name of the delay calculator.</p> required <code>use_ema</code> <code>bool</code> <p>Whether to use en exponentially moving average filter during lockin detection.</p> <code>True</code> <code>n_points</code> <code>int</code> <p>The number of points to scan.</p> <code>1000</code> <code>scan_intervals</code> <code>list[Interval]</code> <p>The intervals to scan.</p> <code>lambda: [Interval(0.0, 1.0)]()</code> <code>integration_periods</code> <code>int</code> <p>The number of integration periods per datapoint to use.</p> <code>10</code> <code>amp_timeout_seconds</code> <code>float</code> <p>The timeout for the connection to the amp in seconds.</p> <code>0.2</code> Source code in <code>src/pyglaze/device/configuration.py</code> <pre><code>@dataclass\nclass LeDeviceConfiguration(DeviceConfiguration):\n    \"\"\"Represents a configuration that can be sent to a Le-type lock-in amp for scans.\n\n    Args:\n        amp_port: The name of the serial port the amp is connected to.\n        delayunit: Name of the delay calculator.\n        use_ema: Whether to use en exponentially moving average filter during lockin detection.\n        n_points: The number of points to scan.\n        scan_intervals: The intervals to scan.\n        integration_periods: The number of integration periods per datapoint to use.\n        amp_timeout_seconds: The timeout for the connection to the amp in seconds.\n    \"\"\"\n\n    amp_port: str\n    delayunit: str\n    use_ema: bool = True\n    n_points: int = 1000\n    scan_intervals: list[Interval] = field(default_factory=lambda: [Interval(0.0, 1.0)])\n    integration_periods: int = 10\n    amp_timeout_seconds: float = 0.2\n\n    modulation_frequency: ClassVar[int] = 10000  # Hz\n    fs_dac_lower_bound: ClassVar[int] = 300\n    fs_dac_upper_bound: ClassVar[int] = 3700\n    amp_baudrate: ClassVar[int] = 1000000  # bit/s\n\n    def __post_init__(self: LeDeviceConfiguration) -&gt; None:  # noqa: D105\n        validate_delayunit(self.delayunit)\n\n    @property\n    def _sweep_length_ms(self: LeDeviceConfiguration) -&gt; float:\n        return self.n_points * self._time_constant_ms\n\n    @property\n    def _time_constant_ms(self: LeDeviceConfiguration) -&gt; float:\n        return 1e3 * self.integration_periods / self.modulation_frequency\n\n    def save(self: LeDeviceConfiguration, path: Path) -&gt; str:\n        \"\"\"Save a LeDeviceConfiguration to a file.\n\n        Args:\n            path: The path to save the configuration to.\n\n        Returns:\n            str: Final path component of the saved file, without the extension.\n\n        \"\"\"\n        with path.open(\"w\") as f:\n            json.dump(asdict(self), f, indent=4, sort_keys=True)\n\n        return path.stem\n\n    @classmethod\n    def from_dict(\n        cls: type[LeDeviceConfiguration], amp_config: dict\n    ) -&gt; LeDeviceConfiguration:\n        \"\"\"Create a LeDeviceConfiguration from a dict.\n\n        Args:\n            amp_config: An amp configuration in dict form.\n\n        Raises:\n            ValueError: If the dictionary is empty.\n\n        Returns:\n            DeviceConfiguration: A DeviceConfiguration object.\n        \"\"\"\n        return _config_w_intervals_from_dict(cls, amp_config)\n\n    @classmethod\n    def load(\n        cls: type[LeDeviceConfiguration], file_path: Path\n    ) -&gt; LeDeviceConfiguration:\n        \"\"\"Load a LeDeviceConfiguration from a file.\n\n        Args:\n            file_path: The path to the file to load.\n\n        Returns:\n            DeviceConfiguration: A DeviceConfiguration object.\n        \"\"\"\n        with file_path.open() as f:\n            configuration_dict = json.load(f)\n        return cls.from_dict(configuration_dict)\n</code></pre>"},{"location":"API%20Reference/device/LeDeviceConfiguration/#pyglaze.device.LeDeviceConfiguration.from_dict","title":"<code>from_dict(amp_config)</code>  <code>classmethod</code>","text":"<p>Create a LeDeviceConfiguration from a dict.</p> <p>Parameters:</p> Name Type Description Default <code>amp_config</code> <code>dict</code> <p>An amp configuration in dict form.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the dictionary is empty.</p> <p>Returns:</p> Name Type Description <code>DeviceConfiguration</code> <code>LeDeviceConfiguration</code> <p>A DeviceConfiguration object.</p> Source code in <code>src/pyglaze/device/configuration.py</code> <pre><code>@classmethod\ndef from_dict(\n    cls: type[LeDeviceConfiguration], amp_config: dict\n) -&gt; LeDeviceConfiguration:\n    \"\"\"Create a LeDeviceConfiguration from a dict.\n\n    Args:\n        amp_config: An amp configuration in dict form.\n\n    Raises:\n        ValueError: If the dictionary is empty.\n\n    Returns:\n        DeviceConfiguration: A DeviceConfiguration object.\n    \"\"\"\n    return _config_w_intervals_from_dict(cls, amp_config)\n</code></pre>"},{"location":"API%20Reference/device/LeDeviceConfiguration/#pyglaze.device.LeDeviceConfiguration.load","title":"<code>load(file_path)</code>  <code>classmethod</code>","text":"<p>Load a LeDeviceConfiguration from a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>The path to the file to load.</p> required <p>Returns:</p> Name Type Description <code>DeviceConfiguration</code> <code>LeDeviceConfiguration</code> <p>A DeviceConfiguration object.</p> Source code in <code>src/pyglaze/device/configuration.py</code> <pre><code>@classmethod\ndef load(\n    cls: type[LeDeviceConfiguration], file_path: Path\n) -&gt; LeDeviceConfiguration:\n    \"\"\"Load a LeDeviceConfiguration from a file.\n\n    Args:\n        file_path: The path to the file to load.\n\n    Returns:\n        DeviceConfiguration: A DeviceConfiguration object.\n    \"\"\"\n    with file_path.open() as f:\n        configuration_dict = json.load(f)\n    return cls.from_dict(configuration_dict)\n</code></pre>"},{"location":"API%20Reference/device/LeDeviceConfiguration/#pyglaze.device.LeDeviceConfiguration.save","title":"<code>save(path)</code>","text":"<p>Save a LeDeviceConfiguration to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to save the configuration to.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Final path component of the saved file, without the extension.</p> Source code in <code>src/pyglaze/device/configuration.py</code> <pre><code>def save(self: LeDeviceConfiguration, path: Path) -&gt; str:\n    \"\"\"Save a LeDeviceConfiguration to a file.\n\n    Args:\n        path: The path to save the configuration to.\n\n    Returns:\n        str: Final path component of the saved file, without the extension.\n\n    \"\"\"\n    with path.open(\"w\") as f:\n        json.dump(asdict(self), f, indent=4, sort_keys=True)\n\n    return path.stem\n</code></pre>"},{"location":"API%20Reference/device/LeDeviceConfiguration/#examples","title":"Examples","text":""},{"location":"API%20Reference/device/LeDeviceConfiguration/#make-a-device-configuration","title":"Make a device configuration","text":"<p>Depending on which device is used, a matching device configuration must be used.</p> Make a device configuration <pre><code>from pyglaze.device import LeDeviceConfiguration\n\nconfig = LeDeviceConfiguration(\n    amp_port=\"mock_device\", delayunit=\"mock_delay\", use_ema=True\n)\n</code></pre> <p>Be sure to use the correct port and delayunit! The <code>mock_device</code> and <code>mock_delay</code> are only for testing purposes</p>"},{"location":"API%20Reference/device/get_device_id/","title":"get_device_id","text":"<p><code>pyglaze.device.get_device_id</code></p> <p>Get the UUID of a device by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>DeviceName</code> <p>The name of the device.</p> required <p>Returns:</p> Type Description <code>UUID</code> <p>Unique identifier of a device.</p> Source code in <code>src/pyglaze/device/identifiers.py</code> <pre><code>def get_device_id(name: DeviceName) -&gt; UUID:\n    \"\"\"Get the UUID of a device by its name.\n\n    Args:\n        name: The name of the device.\n\n    Returns:\n        Unique identifier of a device.\n    \"\"\"\n    try:\n        return _device_ids()[name]\n    except KeyError as e:\n        msg = (\n            f\"Device {name} does not exist. Possible values are {get_args(DeviceName)}\"\n        )\n        raise ValueError(msg) from e\n</code></pre> <p><code>pyglaze.device.list_devices</code></p> <p>List all available devices.</p> <p>Returns:</p> Type Description <code>list[DeviceName]</code> <p>A list of all available devices.</p> Source code in <code>src/pyglaze/device/identifiers.py</code> <pre><code>def list_devices() -&gt; list[DeviceName]:\n    \"\"\"List all available devices.\n\n    Returns:\n        A list of all available devices.\n    \"\"\"\n    return list(_device_ids().keys())\n</code></pre>"},{"location":"API%20Reference/device/get_device_id/#examples","title":"Examples","text":""},{"location":"API%20Reference/device/get_device_id/#find-a-device","title":"Find a device","text":"<p>First, we list all devices</p> <p><pre><code>from pyglaze.device import list_devices\n\nprint(list_devices())\n</code></pre> <pre><code>['glaze1', 'glaze2', 'carmen']\n</code></pre></p> <p>Now, we can get our desired device ID <pre><code>from pyglaze.device import get_device_id\n\nprint(get_device_id(\"carmen\"))\n</code></pre> <pre><code>6a54db26-fa88-4146-b04f-b84b945bfea8\n</code></pre></p>"},{"location":"API%20Reference/device/list_delayunits/","title":"list_delayunits","text":"<p><code>pyglaze.device.list_delayunits</code></p> <p>List all available delayunits.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of all available delayunits.</p> Source code in <code>src/pyglaze/device/delayunit.py</code> <pre><code>def list_delayunits() -&gt; list[str]:\n    \"\"\"List all available delayunits.\n\n    Returns:\n        A list of all available delayunits.\n\n    \"\"\"\n    return [delayunit.stem for delayunit in _DELAYUNITS_PATH.iterdir()]\n</code></pre>"},{"location":"API%20Reference/device/list_delayunits/#examples","title":"Examples","text":""},{"location":"API%20Reference/device/list_delayunits/#find-available-delay-calculators","title":"Find available delay calculators","text":"<p>To list the available delay calculators, use <code>list_delayunits</code>: <pre><code>from pyglaze.device import list_delayunits\n\nprint(list_delayunits())\n</code></pre> <pre><code>['g1-linearized-2023-04-04', 'g2-nonuniform-2023-04-04', 'g2-linearized-2023-04-04', 'mock_delay']\n</code></pre></p>"},{"location":"API%20Reference/device/list_devices/","title":"list_devices","text":"<p><code>pyglaze.device.list_devices</code></p> <p>List all available devices.</p> <p>Returns:</p> Type Description <code>list[DeviceName]</code> <p>A list of all available devices.</p> Source code in <code>src/pyglaze/device/identifiers.py</code> <pre><code>def list_devices() -&gt; list[DeviceName]:\n    \"\"\"List all available devices.\n\n    Returns:\n        A list of all available devices.\n    \"\"\"\n    return list(_device_ids().keys())\n</code></pre>"},{"location":"API%20Reference/scanning/GlazeClient/","title":"GlazeClient","text":"<p><code>pyglaze.scanning.GlazeClient</code></p> <p>Warning</p> <p>Ensure that you are properly connected to the lock-in amp, have it selected, and a configuration is chosen.</p> <p>Open a connection to and start continuously scanning using the Glaze device.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>DeviceConfiguration</code> <p>Configuration to use for scans</p> required Source code in <code>src/pyglaze/scanning/client.py</code> <pre><code>@dataclass\nclass GlazeClient:\n    \"\"\"Open a connection to and start continuously scanning using the Glaze device.\n\n    Args:\n        config: Configuration to use for scans\n    \"\"\"\n\n    config: DeviceConfiguration\n    _scanner: _AsyncScanner = field(init=False)\n\n    def __enter__(self: Self) -&gt; Self:\n        \"\"\"Start the scanner and return the client.\"\"\"\n        self._scanner = _AsyncScanner()\n        try:\n            self._scanner.start_scan(self.config)\n        except (TimeoutError, serialutil.SerialException) as e:\n            self.__exit__(e)\n        return self\n\n    def __exit__(self: GlazeClient, *args: object) -&gt; None:\n        \"\"\"Stop the scanner and close the connection.\"\"\"\n        if self._scanner.is_scanning:\n            self._scanner.stop_scan()\n        # Exit is only called with arguments when an error occurs - hence raise.\n        if args[0]:\n            raise\n\n    def read(self: GlazeClient, n_pulses: int) -&gt; list[UnprocessedWaveform]:\n        \"\"\"Read a number of pulses from the Glaze system.\n\n        Args:\n            n_pulses: The number of terahertz pulses to read from the CCS server.\n        \"\"\"\n        return self._scanner.get_scans(n_pulses)\n</code></pre>"},{"location":"API%20Reference/scanning/GlazeClient/#pyglaze.scanning.GlazeClient.__enter__","title":"<code>__enter__()</code>","text":"<p>Start the scanner and return the client.</p> Source code in <code>src/pyglaze/scanning/client.py</code> <pre><code>def __enter__(self: Self) -&gt; Self:\n    \"\"\"Start the scanner and return the client.\"\"\"\n    self._scanner = _AsyncScanner()\n    try:\n        self._scanner.start_scan(self.config)\n    except (TimeoutError, serialutil.SerialException) as e:\n        self.__exit__(e)\n    return self\n</code></pre>"},{"location":"API%20Reference/scanning/GlazeClient/#pyglaze.scanning.GlazeClient.__exit__","title":"<code>__exit__(*args)</code>","text":"<p>Stop the scanner and close the connection.</p> Source code in <code>src/pyglaze/scanning/client.py</code> <pre><code>def __exit__(self: GlazeClient, *args: object) -&gt; None:\n    \"\"\"Stop the scanner and close the connection.\"\"\"\n    if self._scanner.is_scanning:\n        self._scanner.stop_scan()\n    # Exit is only called with arguments when an error occurs - hence raise.\n    if args[0]:\n        raise\n</code></pre>"},{"location":"API%20Reference/scanning/GlazeClient/#pyglaze.scanning.GlazeClient.read","title":"<code>read(n_pulses)</code>","text":"<p>Read a number of pulses from the Glaze system.</p> <p>Parameters:</p> Name Type Description Default <code>n_pulses</code> <code>int</code> <p>The number of terahertz pulses to read from the CCS server.</p> required Source code in <code>src/pyglaze/scanning/client.py</code> <pre><code>def read(self: GlazeClient, n_pulses: int) -&gt; list[UnprocessedWaveform]:\n    \"\"\"Read a number of pulses from the Glaze system.\n\n    Args:\n        n_pulses: The number of terahertz pulses to read from the CCS server.\n    \"\"\"\n    return self._scanner.get_scans(n_pulses)\n</code></pre>"},{"location":"API%20Reference/scanning/GlazeClient/#examples","title":"Examples","text":"Initialize a Scanner and perform two scans<pre><code>from pyglaze.device import LeDeviceConfiguration\nfrom pyglaze.scanning import GlazeClient\n\n\ndef main() -&gt; None:\n    n_pulses = 2\n    device_config = LeDeviceConfiguration(\n        amp_port=\"mock_device\", delayunit=\"mock_delay\"\n    )\n    with GlazeClient(device_config) as client:\n        unprocessed_waveforms = client.read(n_pulses=n_pulses)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <ol> <li>The config file should be valid JSON of the <code>DeviceConfiguration</code> type. See a list of configuration options under \"API Reference &gt; Device\".</li> </ol>"},{"location":"API%20Reference/scanning/Scanner/","title":"Scanner","text":"<p><code>pyglaze.scanning.Scanner</code></p> <p>A synchronous scanner for Glaze terahertz devices.</p> Source code in <code>src/pyglaze/scanning/scanner.py</code> <pre><code>class Scanner:\n    \"\"\"A synchronous scanner for Glaze terahertz devices.\"\"\"\n\n    def __init__(self: Scanner, config: TConfig) -&gt; None:\n        self._scanner_impl: _ScannerImplementation[DeviceConfiguration] = (\n            _scanner_factory(config)\n        )\n\n    @property\n    def config(self: Scanner) -&gt; DeviceConfiguration:\n        \"\"\"Configuration used in the scan.\"\"\"\n        return self._scanner_impl.config\n\n    @config.setter\n    def config(self: Scanner, new_config: DeviceConfiguration) -&gt; None:\n        self._scanner_impl.config = new_config\n\n    def scan(self: Scanner) -&gt; UnprocessedWaveform:\n        \"\"\"Perform a scan.\n\n        Returns:\n            UnprocessedWaveform: A raw waveform.\n        \"\"\"\n        return self._scanner_impl.scan()\n\n    def update_config(self: Scanner, new_config: DeviceConfiguration) -&gt; None:\n        \"\"\"Update the DeviceConfiguration used in the scan.\n\n        Args:\n            new_config (DeviceConfiguration): New configuration for scanner\n        \"\"\"\n        self._scanner_impl.update_config(new_config)\n</code></pre>"},{"location":"API%20Reference/scanning/Scanner/#pyglaze.scanning.Scanner.config","title":"<code>config: DeviceConfiguration</code>  <code>property</code> <code>writable</code>","text":"<p>Configuration used in the scan.</p>"},{"location":"API%20Reference/scanning/Scanner/#pyglaze.scanning.Scanner.scan","title":"<code>scan()</code>","text":"<p>Perform a scan.</p> <p>Returns:</p> Name Type Description <code>UnprocessedWaveform</code> <code>UnprocessedWaveform</code> <p>A raw waveform.</p> Source code in <code>src/pyglaze/scanning/scanner.py</code> <pre><code>def scan(self: Scanner) -&gt; UnprocessedWaveform:\n    \"\"\"Perform a scan.\n\n    Returns:\n        UnprocessedWaveform: A raw waveform.\n    \"\"\"\n    return self._scanner_impl.scan()\n</code></pre>"},{"location":"API%20Reference/scanning/Scanner/#pyglaze.scanning.Scanner.update_config","title":"<code>update_config(new_config)</code>","text":"<p>Update the DeviceConfiguration used in the scan.</p> <p>Parameters:</p> Name Type Description Default <code>new_config</code> <code>DeviceConfiguration</code> <p>New configuration for scanner</p> required Source code in <code>src/pyglaze/scanning/scanner.py</code> <pre><code>def update_config(self: Scanner, new_config: DeviceConfiguration) -&gt; None:\n    \"\"\"Update the DeviceConfiguration used in the scan.\n\n    Args:\n        new_config (DeviceConfiguration): New configuration for scanner\n    \"\"\"\n    self._scanner_impl.update_config(new_config)\n</code></pre>"},{"location":"API%20Reference/scanning/Scanner/#examples","title":"Examples","text":""},{"location":"API%20Reference/scanning/Scanner/#initialize-a-scanner-and-perform-a-scan","title":"Initialize a Scanner and perform a scan","text":"<p>The config file should be valid JSON conforming to the specific <code>DeviceConfiguration</code> type. See e.g. a definition here. Be sure to replace <code>mock_device</code> and <code>mock_delay</code> with suitable values.</p> ForceDeviceConfigurationLeDeviceConfiguration <pre><code>from pyglaze.device import ForceDeviceConfiguration\nfrom pyglaze.scanning import Scanner\n\ndevice_config = ForceDeviceConfiguration(\n    amp_port=\"mock_device\", sweep_length_ms=10, delayunit=\"mock_delay\"\n)\nscanner = Scanner(config=device_config)\nscan_result = scanner.scan()\n</code></pre> <pre><code>from pyglaze.device import LeDeviceConfiguration\nfrom pyglaze.scanning import Scanner\n\ndevice_config = LeDeviceConfiguration(amp_port=\"mock_device\", delayunit=\"mock_delay\")\nscanner = Scanner(config=device_config)\nscan_result = scanner.scan()\n</code></pre>"}]}